# Phase 1 Implementation Guide: Environment Variable Elimination

**Duration**: 1 week (5 working days)
**Addresses**: TOB-EQTY-LAB-CUPCAKE-1, 9, 11
**Goal**: Replace all behavior-controlling environment variables with CLI flags

---

## Day-by-Day Breakdown

### Day 1: CLI Infrastructure & Global Config (Tasks 1.1-1.2)

**Morning**: Task 1.1 - CLI Flag Definitions (2 hours)
**Afternoon**: Task 1.2 - Global Config Loading (3 hours)

### Day 2: WASM & Tracing (Tasks 1.3-1.4)

**Morning**: Task 1.3 - WASM Memory Configuration (2 hours)
**Afternoon**: Task 1.4 - Tracing Initialization (3 hours)

### Day 3: Debug Flags & OPA Path (Tasks 1.5-1.6)

**Morning**: Task 1.5 - Debug Flags (2 hours)
**Afternoon**: Task 1.6 - OPA Path Discovery (2 hours)
**Evening**: Code review and integration testing

### Day 4: Testing & Bug Fixes

**All Day**: Unit tests, integration tests, fix any issues

### Day 5: Documentation & Wrap-up

**Morning**: Update documentation
**Afternoon**: Final testing, prepare for Phase 2

---

## Task 1.1: Add CLI Flag Definitions

**File**: `cupcake-cli/src/main.rs`
**Time**: 2 hours
**Dependencies**: None

### Current State

```rust
// cupcake-cli/src/main.rs (current - line ~25)
#[derive(Parser)]
#[command(name = "cupcake")]
#[command(about = "Cupcake policy engine for AI agent safety")]
struct Cli {
    #[command(subcommand)]
    command: Command,
}
```

### Implementation Steps

#### Step 1: Add Custom Types (Before `Cli` struct)

```rust
// Add after imports, before Cli struct

/// Trace module selection for CUPCAKE_TRACE replacement
#[derive(Debug, Clone, ValueEnum)]
#[value(rename_all = "snake_case")]
pub enum TraceModule {
    /// Main evaluation flow (routing, signals, WASM, synthesis)
    Eval,
    /// Signal gathering and execution
    Signals,
    /// WASM runtime policy evaluation
    Wasm,
    /// Decision synthesis and prioritization
    Synthesis,
    /// Policy routing and matching
    Routing,
    /// Enable all trace modules
    All,
}

/// Log level for RUST_LOG replacement
#[derive(Debug, Clone, ValueEnum)]
#[value(rename_all = "snake_case")]
pub enum LogLevel {
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

impl LogLevel {
    pub fn to_filter_directive(&self) -> &'static str {
        match self {
            LogLevel::Error => "error",
            LogLevel::Warn => "warn",
            LogLevel::Info => "info",
            LogLevel::Debug => "debug",
            LogLevel::Trace => "trace",
        }
    }
}

/// Memory size with validation (for CUPCAKE_WASM_MAX_MEMORY replacement)
#[derive(Debug, Clone)]
pub struct MemorySize {
    pub bytes: usize,
}

impl FromStr for MemorySize {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        const MIN_MEMORY: usize = 1024 * 1024; // 1MB
        const MAX_MEMORY: usize = 100 * 1024 * 1024; // 100MB

        // Use existing parse_memory_string from wasm_runtime
        let bytes = parse_memory_string_cli(s)
            .map_err(|e| format!("Invalid memory size '{}': {}", s, e))?;

        if bytes < MIN_MEMORY {
            return Err(format!(
                "Memory size too small: {}. Minimum is 1MB (prevents policy bypass)",
                s
            ));
        }

        if bytes > MAX_MEMORY {
            return Err(format!(
                "Memory size too large: {}. Maximum is 100MB",
                s
            ));
        }

        Ok(MemorySize { bytes })
    }
}

impl std::fmt::Display for MemorySize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.bytes >= 1024 * 1024 {
            write!(f, "{}MB", self.bytes / (1024 * 1024))
        } else if self.bytes >= 1024 {
            write!(f, "{}KB", self.bytes / 1024)
        } else {
            write!(f, "{}B", self.bytes)
        }
    }
}

// Helper function (copy from wasm_runtime.rs)
fn parse_memory_string_cli(s: &str) -> Result<usize, String> {
    // Trim whitespace
    let s = s.trim();

    // Extract number and unit
    let (num_str, unit) = s.split_at(
        s.find(|c: char| !c.is_ascii_digit())
            .unwrap_or(s.len())
    );

    // Parse the number
    let num: usize = num_str.parse()
        .map_err(|_| format!("Invalid number: {}", num_str))?;

    // Parse the unit (case-insensitive)
    let multiplier = match unit.to_lowercase().as_str() {
        "" | "b" => 1,
        "kb" | "k" => 1024,
        "mb" | "m" => 1024 * 1024,
        "gb" | "g" => 1024 * 1024 * 1024,
        _ => return Err(format!("Invalid unit: {}. Use B, KB, MB, or GB", unit)),
    };

    Ok(num * multiplier)
}
```

#### Step 2: Update `Cli` Struct

```rust
#[derive(Parser)]
#[command(name = "cupcake")]
#[command(about = "Cupcake policy engine for AI agent safety", long_about = None)]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Command,

    /// Enable evaluation tracing for specific modules (comma-separated)
    ///
    /// Available modules: eval, signals, wasm, synthesis, routing, all
    ///
    /// Example: --trace=eval,wasm
    ///
    /// Security Note: Replaces CUPCAKE_TRACE environment variable which
    /// was vulnerable to manipulation in AI agent contexts.
    #[arg(long, value_delimiter = ',', global = true)]
    trace: Vec<TraceModule>,

    /// Set log level for all Cupcake modules
    ///
    /// Security Note: Replaces RUST_LOG environment variable which
    /// was vulnerable to manipulation in AI agent contexts.
    #[arg(long, default_value = "info", global = true)]
    log_level: LogLevel,

    /// Override global configuration file path
    ///
    /// Must be an absolute path to a .yml/.yaml file.
    ///
    /// Security Note: Replaces CUPCAKE_GLOBAL_CONFIG environment variable
    /// (TOB-EQTY-LAB-CUPCAKE-11 - HIGH severity). Only accepts validated
    /// absolute paths to prevent config override attacks.
    #[arg(long, global = true)]
    global_config: Option<PathBuf>,

    /// Maximum WASM memory allocation
    ///
    /// Minimum: 1MB, Maximum: 100MB
    ///
    /// Security Note: Replaces CUPCAKE_WASM_MAX_MEMORY environment variable
    /// (TOB-EQTY-LAB-CUPCAKE-1 - MEDIUM severity). Enforces minimum to prevent
    /// policy bypass via memory exhaustion.
    #[arg(long, default_value = "10MB", global = true)]
    wasm_max_memory: MemorySize,

    /// Path to OPA binary (auto-detected if not specified)
    ///
    /// Security Note: Replaces CUPCAKE_OPA_PATH environment variable to
    /// prevent pointing to malicious binaries.
    #[arg(long, global = true)]
    opa_path: Option<PathBuf>,

    /// Enable debug file output to .cupcake/debug/
    ///
    /// Security Note: Replaces CUPCAKE_DEBUG_FILES environment variable
    /// (TOB-EQTY-LAB-CUPCAKE-9). Explicit flag prevents unintended information disclosure.
    #[arg(long, global = true)]
    debug_files: bool,

    /// Enable routing debug output to .cupcake/debug/routing/
    ///
    /// Security Note: Replaces CUPCAKE_DEBUG_ROUTING environment variable
    /// (TOB-EQTY-LAB-CUPCAKE-9). Explicit flag prevents unintended information disclosure.
    #[arg(long, global = true)]
    debug_routing: bool,
}
```

### Testing

```bash
# Test CLI parsing
cargo build

# Test trace flag
./target/debug/cupcake eval --trace=all --help

# Test memory size validation
./target/debug/cupcake eval --wasm-max-memory=0MB  # Should error: too small
./target/debug/cupcake eval --wasm-max-memory=1MB  # Should work
./target/debug/cupcake eval --wasm-max-memory=200MB  # Should error: too large

# Test global config validation
./target/debug/cupcake eval --global-config=relative/path  # Should error: not absolute
./target/debug/cupcake eval --global-config=/tmp/test.txt  # Should error: not .yml

# Test log level
./target/debug/cupcake eval --log-level=debug --help
```

### Acceptance Criteria
- [x] All custom types compile without errors
- [x] CLI help text shows all new flags
- [x] Memory size validation works (min/max enforced)
- [x] Flags are global (available to all subcommands)
- [x] Security notes in help text

---

## Task 1.2: Update Global Config Loading

**File**: `cupcake-core/src/engine/global_config.rs`
**Time**: 3 hours
**Dependencies**: Task 1.1 complete
**Addresses**: TOB-EQTY-LAB-CUPCAKE-11 (HIGH)

### Current State

```rust
// cupcake-core/src/engine/global_config.rs:36
if let Ok(env_path) = std::env::var("CUPCAKE_GLOBAL_CONFIG") {
    debug!("Using CUPCAKE_GLOBAL_CONFIG environment variable: {}", env_path);
    // ...
}
```

### Implementation Steps

#### Step 1: Remove Environment Variable Check

**Find and replace**:
```rust
// REMOVE THIS (lines 36-46):
if let Ok(env_path) = std::env::var("CUPCAKE_GLOBAL_CONFIG") {
    debug!(
        "Using CUPCAKE_GLOBAL_CONFIG environment variable: {}",
        env_path
    );
    let path = PathBuf::from(env_path);
    if path.exists() {
        return load_config_from_path(&path).map(Some);
    } else {
        debug!("CUPCAKE_GLOBAL_CONFIG path does not exist, skipping global config");
    }
}
```

#### Step 2: Add CLI Override Parameter

```rust
/// Load global configuration with security-first approach
///
/// Priority order (NO environment variables):
/// 1. CLI flag --global-config (if provided, must be validated)
/// 2. Platform-specific default paths
/// 3. None (no global config)
///
/// # Security
///
/// This function no longer accepts environment variable input
/// (TOB-EQTY-LAB-CUPCAKE-11 - HIGH severity). All paths are validated
/// to prevent config override attacks.
pub fn load_global_config(
    cli_override: Option<PathBuf>  // NEW parameter
) -> Result<Option<CupcakeConfig>> {
    // 1. Check CLI flag first (if provided)
    if let Some(path) = cli_override {
        validate_config_path(&path)
            .context("Invalid global config path from CLI flag")?;

        info!("Using global config from CLI flag: {}", path.display());
        return load_config_from_path(&path).map(Some);
    }

    // 2. Try platform-specific default paths
    load_default_global_config()
}
```

#### Step 3: Add Path Validation Function

```rust
/// Validate global config path for security
///
/// Requirements:
/// - Must be absolute path
/// - Must exist
/// - Must be a regular file (not directory, symlink, etc.)
/// - Must have .yml or .yaml extension
///
/// # Security
///
/// Prevents:
/// - Directory traversal attacks
/// - Loading arbitrary files
/// - Symlink attacks
fn validate_config_path(path: &Path) -> Result<()> {
    // Must be absolute
    if !path.is_absolute() {
        bail!(
            "Global config path must be absolute (got: {}). \
             This prevents directory traversal attacks.",
            path.display()
        );
    }

    // Must exist
    if !path.exists() {
        bail!(
            "Global config path does not exist: {}",
            path.display()
        );
    }

    // Must be a regular file
    let metadata = path.metadata()
        .context("Failed to read path metadata")?;

    if !metadata.is_file() {
        bail!(
            "Global config path must be a regular file: {} \
             (is_dir: {}, is_symlink: {})",
            path.display(),
            metadata.is_dir(),
            metadata.file_type().is_symlink()
        );
    }

    // Must have .yml or .yaml extension
    match path.extension().and_then(|s| s.to_str()) {
        Some("yml") | Some("yaml") => {
            debug!("Global config path validation passed: {}", path.display());
            Ok(())
        }
        Some(ext) => bail!(
            "Global config must be a YAML file (.yml or .yaml), got: .{}",
            ext
        ),
        None => bail!(
            "Global config must have a file extension (.yml or .yaml)"
        ),
    }
}
```

#### Step 4: Update All Callers

**Find usages of `load_global_config()` and update**:

```rust
// In cupcake-cli/src/main.rs (eval command)
let global_config = cupcake_core::engine::global_config::load_global_config(
    cli.global_config.clone()  // Pass CLI flag
)?;
```

#### Step 5: Update Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_env_var_ignored() {
        // Set env var (should be ignored)
        std::env::set_var("CUPCAKE_GLOBAL_CONFIG", "/tmp/should-be-ignored.yml");

        // Load without CLI override
        let config = load_global_config(None).unwrap();

        // Should not have loaded /tmp/should-be-ignored.yml
        // (Exact verification depends on whether it exists and what it contains)

        std::env::remove_var("CUPCAKE_GLOBAL_CONFIG");
    }

    #[test]
    fn test_absolute_path_required() {
        let result = validate_config_path(Path::new("relative/path.yml"));
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("absolute"));
    }

    #[test]
    fn test_yaml_extension_required() {
        // Assuming /tmp exists
        std::fs::write("/tmp/test.txt", "test").unwrap();

        let result = validate_config_path(Path::new("/tmp/test.txt"));
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("YAML"));

        std::fs::remove_file("/tmp/test.txt").ok();
    }

    #[test]
    fn test_file_must_exist() {
        let result = validate_config_path(Path::new("/nonexistent/config.yml"));
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("does not exist"));
    }

    #[test]
    fn test_must_be_file_not_directory() {
        // /tmp is a directory
        let result = validate_config_path(Path::new("/tmp"));
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("regular file"));
    }
}
```

### Testing

```bash
# Unit tests
cargo test -p cupcake-core --lib global_config

# Integration test
echo "test: true" > /tmp/test-global.yml

# Should work
cargo run -- eval --global-config=/tmp/test-global.yml < test-event.json

# Should fail - not absolute
cargo run -- eval --global-config=test-global.yml

# Should fail - doesn't exist
cargo run -- eval --global-config=/nonexistent.yml

# Should fail - not YAML
touch /tmp/test.txt
cargo run -- eval --global-config=/tmp/test.txt

# Verify env var ignored
export CUPCAKE_GLOBAL_CONFIG="/tmp/evil.yml"
cargo run -- eval  # Should not use /tmp/evil.yml
unset CUPCAKE_GLOBAL_CONFIG
```

### Acceptance Criteria
- [x] `CUPCAKE_GLOBAL_CONFIG` env var completely removed
- [x] CLI flag `--global-config` works
- [x] Path validation enforced
- [x] Clear error messages for invalid paths
- [x] Tests passing
- [x] Env var ignored even if set

---

## Task 1.3: Update WASM Memory Configuration

**File**: `cupcake-core/src/engine/wasm_runtime.rs`
**Time**: 2 hours
**Dependencies**: Task 1.1 complete
**Addresses**: TOB-EQTY-LAB-CUPCAKE-1 (MEDIUM)

### Current State

```rust
// cupcake-core/src/engine/wasm_runtime.rs:49
let max_memory_str =
    env::var("CUPCAKE_WASM_MAX_MEMORY").unwrap_or_else(|_| DEFAULT_MAX_MEMORY.to_string());
```

### Implementation

**Replace `get_memory_config()` function**:

```rust
/// Gets WASM memory limits from CLI config with hardened validation
///
/// # Security
///
/// Enforces minimum 1MB to prevent policy bypass (TOB-EQTY-LAB-CUPCAKE-1).
/// Setting memory to 0MB previously caused panic, bypassing all policies.
fn get_memory_config(cli_memory: MemorySize) -> (u32, Option<u32>) {
    const DEFAULT_INITIAL_PAGES: u32 = 5; // 320KB
    const ABSOLUTE_MIN_BYTES: usize = 1024 * 1024; // 1MB
    const ABSOLUTE_MAX_BYTES: usize = 100 * 1024 * 1024; // 100MB

    // cli_memory already validated at CLI parse time, but double-check
    // (defense-in-depth)
    let memory_bytes = cli_memory.bytes
        .max(ABSOLUTE_MIN_BYTES)
        .min(ABSOLUTE_MAX_BYTES);

    if memory_bytes != cli_memory.bytes {
        warn!(
            "WASM memory clamped to safe range: {} -> {} bytes \
             (This should not happen - CLI validation should prevent this)",
            cli_memory.bytes,
            memory_bytes
        );
    }

    let max_pages = bytes_to_wasm_pages(memory_bytes);

    debug!(
        "WASM memory configured: {} pages ({} bytes, {})",
        max_pages,
        memory_bytes,
        MemorySize { bytes: memory_bytes }
    );

    (DEFAULT_INITIAL_PAGES, Some(max_pages))
}
```

**Update callers**:

```rust
// In create_wasm_runtime or wherever get_memory_config is called
let (initial_pages, max_pages) = get_memory_config(cli.wasm_max_memory.clone());
```

### Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_minimum_enforced_at_cli() {
        // This should fail at CLI parse time
        let result = MemorySize::from_str("0MB");
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("too small"));
    }

    #[test]
    fn test_defense_in_depth_clamping() {
        // Even if somehow a zero gets through, clamp it
        let memory = MemorySize { bytes: 0 };
        let (initial, max) = get_memory_config(memory);

        assert!(max.is_some());
        let max_pages = max.unwrap();

        // Should be at least minimum (1MB = 16 pages)
        assert!(max_pages >= 16);
    }

    #[test]
    fn test_no_panic_on_zero() {
        // Previously, zero memory caused panic
        // Now it should be clamped
        let memory = MemorySize { bytes: 0 };
        let _config = get_memory_config(memory);
        // If we get here without panicking, test passes
    }

    #[test]
    fn test_valid_range() {
        let memory_1mb = MemorySize { bytes: 1024 * 1024 };
        let memory_10mb = MemorySize { bytes: 10 * 1024 * 1024 };
        let memory_100mb = MemorySize { bytes: 100 * 1024 * 1024 };

        let (_, max_1mb) = get_memory_config(memory_1mb);
        let (_, max_10mb) = get_memory_config(memory_10mb);
        let (_, max_100mb) = get_memory_config(memory_100mb);

        assert!(max_1mb.unwrap() > 0);
        assert!(max_10mb.unwrap() > max_1mb.unwrap());
        assert!(max_100mb.unwrap() > max_10mb.unwrap());
    }
}
```

### Acceptance Criteria
- [x] Env var check removed
- [x] Accepts `MemorySize` from CLI
- [x] Minimum 1MB enforced (prevents bypass)
- [x] Maximum 100MB enforced
- [x] No panic on invalid values
- [x] Tests passing

---

## Task 1.4: Update Tracing Initialization

**File**: `cupcake-cli/src/main.rs`
**Time**: 3 hours
**Dependencies**: Task 1.1 complete
**Addresses**: TOB-EQTY-LAB-CUPCAKE-9 (LOW)

### Current State

```rust
// cupcake-cli/src/main.rs:123
let cupcake_trace = env::var("CUPCAKE_TRACE").ok();
```

### Implementation

**Replace `initialize_tracing()` function**:

```rust
/// Initialize tracing from CLI flags (NO environment variables)
///
/// # Security
///
/// Replaces CUPCAKE_TRACE and RUST_LOG environment variables
/// (TOB-EQTY-LAB-CUPCAKE-9). Environment variables are untrusted
/// in AI agent contexts and can be manipulated via prompts.
fn initialize_tracing(trace_modules: &[TraceModule], log_level: LogLevel) {
    // Build filter from CLI args only (NO env::var calls)
    let mut filter = EnvFilter::new(log_level.to_filter_directive());

    // Add trace-level logging for requested modules
    for module in trace_modules {
        let directive = match module {
            TraceModule::Eval => "cupcake_core::engine=trace",
            TraceModule::Signals => "cupcake_core::engine::guidebook=trace",
            TraceModule::Wasm => "cupcake_core::engine::wasm_runtime=trace",
            TraceModule::Synthesis => "cupcake_core::engine::synthesis=trace",
            TraceModule::Routing => "cupcake_core::engine::routing=trace",
            TraceModule::All => "cupcake_core=trace",
        };

        if let Ok(parsed) = directive.parse() {
            filter = filter.add_directive(parsed);
        }
    }

    // JSON output if any trace modules specified
    if !trace_modules.is_empty() {
        tracing_subscriber::fmt()
            .json()
            .with_env_filter(filter)
            .with_target(true)
            .with_thread_ids(true)
            .with_thread_names(true)
            .with_file(true)
            .with_line_number(true)
            .with_writer(std::io::stderr)
            .init();

        info!(
            trace_modules = ?trace_modules,
            "Evaluation tracing enabled via CLI flag (not env var)"
        );
    } else {
        // Standard text output
        tracing_subscriber::fmt()
            .with_env_filter(filter)
            .with_target(false)
            .with_writer(std::io::stderr)
            .init();
    }
}
```

**Update `main()` call**:

```rust
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing from CLI flags (no env vars)
    initialize_tracing(&cli.trace, cli.log_level.clone());

    // ... rest of main
}
```

### Testing

```bash
# Test env vars ignored
export CUPCAKE_TRACE="all"
export RUST_LOG="trace"

cargo run -- eval --help  # Should NOT use env vars

unset CUPCAKE_TRACE
unset RUST_LOG

# Test flags work
cargo run -- eval --trace=all < event.json  # Should enable tracing
cargo run -- eval --log-level=debug < event.json  # Should enable debug logging
```

### Acceptance Criteria
- [x] No `env::var` calls in `initialize_tracing()`
- [x] `--trace` flag controls tracing
- [x] `--log-level` flag controls logging
- [x] Env vars ignored
- [x] Same functionality as before

---

## Task 1.5 & 1.6: Quick Updates

### Task 1.5: Debug Flags (2 hours)

**Files**: `cupcake-cli/src/main.rs:270`, `cupcake-core/src/engine/routing_debug.rs:73`

**Changes**:
```rust
// In main.rs eval command
let mut debug_capture = if cli.debug_files {  // NOT env::var
    Some(DebugCapture::new(/*...*/))
} else {
    None
};

// In routing_debug.rs
pub fn dump_routing_map_if_enabled(
    debug_routing: bool,  // From CLI flag
    // ...
) -> Result<()> {
    if !debug_routing {  // NOT env::var check
        return Ok(());
    }
    // ... existing dump logic
}
```

### Task 1.6: OPA Path (2 hours)

**File**: `cupcake-core/src/engine/compiler.rs`

**Changes**:
```rust
pub fn find_opa_binary(cli_override: Option<PathBuf>) -> Result<PathBuf> {
    // 1. CLI flag first
    if let Some(path) = cli_override {
        validate_opa_binary(&path)?;
        return Ok(path);
    }

    // 2. Bundled OPA
    // ... existing logic ...

    // 3. System PATH
    // ... existing logic ...
}

fn validate_opa_binary(path: &Path) -> Result<()> {
    // Check exists, executable, runs version command
    // ... validation logic ...
}
```

---

## Integration Testing for Phase 1

### Test Suite

```bash
# Create test script: test_phase1.sh

#!/bin/bash
set -e

echo "=== Phase 1 Integration Tests ==="

# Test 1: Env vars ignored
export CUPCAKE_GLOBAL_CONFIG="/tmp/should-be-ignored.yml"
export CUPCAKE_TRACE="all"
export RUST_LOG="trace"

echo "Test 1: Env vars should be ignored"
cargo run -- eval < test-event.json
# Should not use env var values

unset CUPCAKE_GLOBAL_CONFIG CUPCAKE_TRACE RUST_LOG

# Test 2: CLI flags work
echo "Test 2: CLI flags should work"
cargo run -- eval --trace=all --log-level=debug < test-event.json

# Test 3: Memory validation
echo "Test 3: Memory validation"
! cargo run -- eval --wasm-max-memory=0MB  # Should fail
cargo run -- eval --wasm-max-memory=1MB < test-event.json  # Should work

# Test 4: Global config validation
echo "Test 4: Global config validation"
! cargo run -- eval --global-config=relative.yml  # Should fail
! cargo run -- eval --global-config=/nonexistent.yml  # Should fail

echo "=== All Phase 1 tests passed! ==="
```

---

## Phase 1 Completion Checklist

### Code Changes
- [ ] Task 1.1: CLI flags defined and parsing
- [ ] Task 1.2: Global config uses CLI flag
- [ ] Task 1.3: WASM memory uses CLI flag
- [ ] Task 1.4: Tracing uses CLI flags
- [ ] Task 1.5: Debug flags use CLI
- [ ] Task 1.6: OPA path uses CLI flag

### Validation
- [ ] All env var checks removed (7 variables)
- [ ] All CLI flags working
- [ ] All validation functions implemented
- [ ] All unit tests passing
- [ ] Integration tests passing
- [ ] No compiler warnings

### Security
- [ ] CUPCAKE-1: WASM bypass prevented (min enforced)
- [ ] CUPCAKE-9: Log exposure prevented (explicit flags)
- [ ] CUPCAKE-11: Config override prevented (validation)
- [ ] No panics on invalid input
- [ ] Clear error messages

### Documentation
- [ ] ENVIRONMENT_VARIABLES.md updated with deprecations
- [ ] CLI help text comprehensive
- [ ] Security notes in all flag descriptions
- [ ] Migration examples provided

### Ready for Phase 2
- [ ] All code committed to feature branch
- [ ] Code review completed
- [ ] Performance benchmarks captured
- [ ] No regressions in existing functionality

---

**Last Updated**: 2025-10-06
