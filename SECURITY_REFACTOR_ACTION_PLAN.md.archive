# Cupcake Security Refactor - Action Plan

**Date**: 2025-10-06
**Status**: Draft for Review
**Priority**: High - Addresses Critical Security Findings
**Scope**: Full implementation refactor (no backward compatibility constraints)

---

## Executive Summary

This action plan addresses **11 security findings** from Trail of Bits' security audit (September 2025), with focus on eliminating environment variable vulnerabilities and implementing defense-in-depth for AI agent execution contexts.

**Key Changes**:
- Remove 7 security-critical environment variables
- Replace with CLI flags and hardened config files
- Eliminate shell command injection vulnerabilities
- Implement fail-safe defaults throughout
- Add runtime security validation layer

**Timeline**: 4-6 weeks (phased implementation)
**Risk**: Low (full refactor allows clean architecture)

---

## Table of Contents

1. [Security Findings Reference](#security-findings-reference)
2. [Phase 1: Environment Variable Elimination](#phase-1-environment-variable-elimination)
3. [Phase 2: Shell Command Hardening](#phase-2-shell-command-hardening)
4. [Phase 3: Trust System Improvements](#phase-3-trust-system-improvements)
5. [Phase 4: Policy System Hardening](#phase-4-policy-system-hardening)
6. [Phase 5: Testing & Validation](#phase-5-testing--validation)
7. [Implementation Timeline](#implementation-timeline)
8. [Success Criteria](#success-criteria)

---

## Security Findings Reference

### Trail of Bits Findings - Priority Matrix

| ID | Title | Severity | Difficulty | Phase |
|----|-------|----------|------------|-------|
| **TOB-EQTY-LAB-CUPCAKE-11** | Global Config Override | High | Low | 1 |
| **TOB-EQTY-LAB-CUPCAKE-1** | WASM Memory Bypass | Medium | Low | 1 |
| **TOB-EQTY-LAB-CUPCAKE-9** | Log Exposure | Low | Low | 1 |
| **TOB-EQTY-LAB-CUPCAKE-2** | Signal Bash Injection | High | Low | 2 |
| **TOB-EQTY-LAB-CUPCAKE-4** | Signal Command Injection | High | Low | 2 |
| **TOB-EQTY-LAB-CUPCAKE-8** | Action Command Injection | High | Low | 2 |
| **TOB-EQTY-LAB-CUPCAKE-3** | Trust Path Traversal | Medium | Medium | 3 |
| **TOB-EQTY-LAB-CUPCAKE-6** | Trust Manifest Modification | Medium | Medium | 3 |
| **TOB-EQTY-LAB-CUPCAKE-5** | Policy Namespace Override | Low | Low | 4 |
| **TOB-EQTY-LAB-CUPCAKE-10** | Global Deny Overrides Ask | Medium | Medium | 4 |
| **TOB-EQTY-LAB-CUPCAKE-7** | Feedback Loop Race | Info | - | 5 |

**Critical Path**: Findings #11, #1, #2, #4, #8 (all enable RCE or bypass)

---

## Phase 1: Environment Variable Elimination

**Goal**: Remove all behavior-controlling environment variables, replace with CLI flags
**Duration**: 1 week
**Risk**: Low (full refactor)
**Addresses**: TOB-EQTY-LAB-CUPCAKE-1, 9, 11

### 1.1 Architecture Changes

#### Current Architecture (Vulnerable):
```rust
// Env vars checked at runtime, can be manipulated
let trace = env::var("CUPCAKE_TRACE").ok();
let global_config = env::var("CUPCAKE_GLOBAL_CONFIG").ok();
let wasm_memory = env::var("CUPCAKE_WASM_MAX_MEMORY")
    .unwrap_or_else(|_| "10MB".to_string());
```

#### New Architecture (Secure):
```rust
// CLI flags only, explicit per-invocation
#[derive(Parser)]
struct Cli {
    #[command(subcommand)]
    command: Command,

    /// Enable evaluation tracing (eval, signals, wasm, synthesis, routing, all)
    #[arg(long, value_delimiter = ',')]
    trace: Option<Vec<TraceModule>>,

    /// Set log level (error, warn, info, debug, trace)
    #[arg(long, default_value = "info")]
    log_level: LogLevel,

    /// Override global configuration file path
    #[arg(long)]
    global_config: Option<PathBuf>,

    /// Maximum WASM memory allocation (min: 1MB, max: 100MB)
    #[arg(long, default_value = "10MB")]
    wasm_max_memory: MemorySize,

    /// Path to OPA binary (auto-detected if not specified)
    #[arg(long)]
    opa_path: Option<PathBuf>,

    /// Enable debug file output to .cupcake/debug/
    #[arg(long)]
    debug_files: bool,

    /// Enable routing debug output to .cupcake/debug/routing/
    #[arg(long)]
    debug_routing: bool,
}
```

### 1.2 Environment Variable Removal Plan

#### Variables to REMOVE (7 total):

| Env Var | Replacement | Code Location | ToB Finding |
|---------|-------------|---------------|-------------|
| `CUPCAKE_GLOBAL_CONFIG` | `--global-config=<path>` | `global_config.rs:36` | CUPCAKE-11 |
| `CUPCAKE_WASM_MAX_MEMORY` | `--wasm-max-memory=<size>` | `wasm_runtime.rs:49` | CUPCAKE-1 |
| `CUPCAKE_TRACE` | `--trace=<modules>` | `main.rs:123` | CUPCAKE-9 |
| `RUST_LOG` | `--log-level=<level>` | `main.rs:126` | CUPCAKE-9 |
| `CUPCAKE_DEBUG_FILES` | `--debug-files` | `main.rs:270` | CUPCAKE-9 |
| `CUPCAKE_DEBUG_ROUTING` | `--debug-routing` | `routing_debug.rs:73` | CUPCAKE-9 |
| `CUPCAKE_OPA_PATH` | `--opa-path=<path>` | `compiler.rs:32` | (preventive) |

#### Variables to KEEP (12 total):

**Install-time only** (not runtime behavior):
- `CUPCAKE_REPO`, `CUPCAKE_VERSION`, `CUPCAKE_INSTALL_DIR`, `CUPCAKE_NO_TELEMETRY`

**OS-provided** (read-only, safe):
- `HOME`, `APPDATA`, `USERPROFILE`, `USER`, `USERNAME`

**External tools** (documentation only):
- `RUST_BACKTRACE`, `PYTHONFAULTHANDLER`, `TOKIO_CONSOLE`

### 1.3 Implementation Tasks

#### Task 1.1: Add CLI Flag Definitions
**File**: `cupcake-cli/src/main.rs`
**Estimated Time**: 2 hours

```rust
// Add new CLI argument types
#[derive(Debug, Clone, ValueEnum)]
enum TraceModule {
    Eval,
    Signals,
    Wasm,
    Synthesis,
    Routing,
    All,
}

#[derive(Debug, Clone, ValueEnum)]
enum LogLevel {
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

// Custom type for memory size with validation
#[derive(Debug, Clone)]
struct MemorySize {
    bytes: usize,
}

impl FromStr for MemorySize {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        const MIN_MEMORY: usize = 1024 * 1024; // 1MB
        const MAX_MEMORY: usize = 100 * 1024 * 1024; // 100MB

        let bytes = parse_memory_string(s)
            .map_err(|e| format!("Invalid memory size: {}", e))?;

        if bytes < MIN_MEMORY {
            return Err(format!(
                "Memory size too small: {}. Minimum is 1MB",
                s
            ));
        }

        if bytes > MAX_MEMORY {
            return Err(format!(
                "Memory size too large: {}. Maximum is 100MB",
                s
            ));
        }

        Ok(MemorySize { bytes })
    }
}
```

**Acceptance Criteria**:
- ✅ All 7 env vars have corresponding CLI flags
- ✅ Memory size validation enforces 1MB-100MB range (addresses CUPCAKE-1)
- ✅ Help text documents security rationale
- ✅ Type-safe enums prevent invalid values

---

#### Task 1.2: Update Global Config Loading
**File**: `cupcake-core/src/engine/global_config.rs`
**Estimated Time**: 3 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-11 (HIGH)

```rust
// REMOVE env var check entirely
pub fn load_global_config(
    cli_override: Option<PathBuf>  // NEW: from CLI flag only
) -> Result<Option<CupcakeConfig>> {
    // Priority order (NO env var):
    // 1. CLI flag --global-config (if provided)
    // 2. Platform-specific default paths
    // 3. None (no global config)

    if let Some(path) = cli_override {
        // Validate path before loading (NEW: security check)
        validate_config_path(&path)?;

        info!("Using global config from CLI flag: {}", path.display());
        return load_config_from_path(&path).map(Some);
    }

    // Fall back to platform defaults (hardcoded, not env var)
    load_default_global_config()
}

// NEW: Path validation to prevent directory traversal
fn validate_config_path(path: &Path) -> Result<()> {
    // Must be absolute
    if !path.is_absolute() {
        bail!("Global config path must be absolute: {}", path.display());
    }

    // Must exist
    if !path.exists() {
        bail!("Global config path does not exist: {}", path.display());
    }

    // Must be a file (not directory, symlink, etc.)
    if !path.is_file() {
        bail!("Global config path must be a regular file: {}", path.display());
    }

    // Must have .yml or .yaml extension
    match path.extension().and_then(|s| s.to_str()) {
        Some("yml") | Some("yaml") => Ok(()),
        _ => bail!("Global config must be a YAML file (.yml or .yaml)"),
    }
}
```

**Acceptance Criteria**:
- ✅ `CUPCAKE_GLOBAL_CONFIG` env var removed completely
- ✅ Only `--global-config` CLI flag accepted
- ✅ Path validation prevents directory traversal
- ✅ Clear error messages on invalid paths
- ✅ No breaking change to default behavior (still checks platform paths)

---

#### Task 1.3: Update WASM Memory Configuration
**File**: `cupcake-core/src/engine/wasm_runtime.rs`
**Estimated Time**: 2 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-1 (MEDIUM)

```rust
/// Gets WASM memory limits from CLI config with hardened validation
fn get_memory_config(cli_memory: MemorySize) -> (u32, Option<u32>) {
    const DEFAULT_INITIAL_PAGES: u32 = 5; // 320KB
    const ABSOLUTE_MIN_BYTES: usize = 1024 * 1024; // 1MB (enforced at CLI parse)
    const ABSOLUTE_MAX_BYTES: usize = 100 * 1024 * 1024; // 100MB

    // cli_memory already validated at parse time, but double-check
    let memory_bytes = cli_memory.bytes
        .max(ABSOLUTE_MIN_BYTES)
        .min(ABSOLUTE_MAX_BYTES);

    if memory_bytes != cli_memory.bytes {
        warn!(
            "WASM memory clamped to safe range: {} -> {} bytes",
            cli_memory.bytes,
            memory_bytes
        );
    }

    let max_pages = bytes_to_wasm_pages(memory_bytes);

    debug!(
        "WASM memory configured: {} pages ({} bytes)",
        max_pages,
        memory_bytes
    );

    (DEFAULT_INITIAL_PAGES, Some(max_pages))
}
```

**Key Changes**:
- ✅ Remove `env::var("CUPCAKE_WASM_MAX_MEMORY")` check
- ✅ Accept `MemorySize` from CLI (already validated)
- ✅ Enforce minimum 1MB (prevents CUPCAKE-1 bypass)
- ✅ Double-check bounds even after CLI validation (defense-in-depth)
- ✅ Log when clamping occurs

**Acceptance Criteria**:
- ✅ Cannot set memory to 0MB (bypass prevented)
- ✅ Cannot set memory < 1MB or > 100MB
- ✅ Clear error at CLI parse time for invalid values
- ✅ Panic-free operation (no bypass via crash)

---

#### Task 1.4: Update Tracing Initialization
**File**: `cupcake-cli/src/main.rs`
**Estimated Time**: 3 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-9 (LOW)

```rust
/// Initialize tracing from CLI flags (NOT environment variables)
fn initialize_tracing(trace_modules: &[TraceModule], log_level: LogLevel) {
    // Build filter from CLI args only (NO env vars)
    let mut filter = EnvFilter::new(log_level.to_filter_directive());

    // Add trace-level logging for requested modules
    for module in trace_modules {
        let directive = match module {
            TraceModule::Eval => "cupcake_core::engine=trace",
            TraceModule::Signals => "cupcake_core::engine::guidebook=trace",
            TraceModule::Wasm => "cupcake_core::engine::wasm_runtime=trace",
            TraceModule::Synthesis => "cupcake_core::engine::synthesis=trace",
            TraceModule::Routing => "cupcake_core::engine::routing=trace",
            TraceModule::All => "cupcake_core=trace",
        };

        if let Ok(parsed) = directive.parse() {
            filter = filter.add_directive(parsed);
        }
    }

    // JSON output if any trace modules specified
    if !trace_modules.is_empty() {
        tracing_subscriber::fmt()
            .json()
            .with_env_filter(filter)
            .with_target(true)
            .with_thread_ids(true)
            .with_thread_names(true)
            .with_file(true)
            .with_line_number(true)
            .with_writer(std::io::stderr)
            .init();

        info!(
            trace_modules = ?trace_modules,
            "Evaluation tracing enabled via CLI flag"
        );
    } else {
        // Standard text output
        tracing_subscriber::fmt()
            .with_env_filter(filter)
            .with_target(false)
            .with_writer(std::io::stderr)
            .init();
    }
}

impl LogLevel {
    fn to_filter_directive(&self) -> &'static str {
        match self {
            LogLevel::Error => "error",
            LogLevel::Warn => "warn",
            LogLevel::Info => "info",
            LogLevel::Debug => "debug",
            LogLevel::Trace => "trace",
        }
    }
}
```

**Key Changes**:
- ✅ Remove `env::var("CUPCAKE_TRACE")` check
- ✅ Remove `env::var("RUST_LOG")` fallback
- ✅ Use CLI flags exclusively
- ✅ Maintain same functionality, better security

**Acceptance Criteria**:
- ✅ `CUPCAKE_TRACE` env var no longer checked
- ✅ `RUST_LOG` env var no longer checked
- ✅ `--trace` flag provides same functionality
- ✅ `--log-level` flag replaces RUST_LOG
- ✅ Information disclosure prevented (explicit flags required)

---

#### Task 1.5: Update Debug File and Routing Debug
**Files**:
- `cupcake-cli/src/main.rs:270`
- `cupcake-core/src/engine/routing_debug.rs:73`
**Estimated Time**: 2 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-9 (LOW)

```rust
// In cupcake-cli/src/main.rs - eval command
Command::Eval {
    policy_dir,
    debug,
    strict,
} => {
    // NEW: Get from CLI args, not env var
    let debug_capture = if cli.debug_files {
        let trace_id = cupcake_core::engine::trace::generate_trace_id();
        Some(DebugCapture::new(
            serde_json::from_str(&input_json)?,
            trace_id,
        ))
    } else {
        None
    };

    // ...
}

// In cupcake-core/src/engine/routing_debug.rs
pub fn dump_routing_map_if_enabled(
    debug_routing: bool,  // NEW: from CLI flag
    project_map: &RoutingMap,
    global_map: Option<&RoutingMap>,
) -> Result<()> {
    // Remove env var check
    if !debug_routing {
        return Ok(());
    }

    // ... existing dump logic
}
```

**Acceptance Criteria**:
- ✅ `CUPCAKE_DEBUG_FILES` env var removed
- ✅ `CUPCAKE_DEBUG_ROUTING` env var removed
- ✅ `--debug-files` flag controls debug output
- ✅ `--debug-routing` flag controls routing dump

---

#### Task 1.6: Update OPA Path Discovery
**File**: `cupcake-core/src/engine/compiler.rs`
**Estimated Time**: 2 hours

```rust
/// Find the OPA binary with security-first approach
pub fn find_opa_binary(cli_override: Option<PathBuf>) -> Result<PathBuf> {
    // Priority order (NO env var):
    // 1. CLI flag --opa-path (if provided)
    // 2. Bundled OPA (same directory as cupcake binary)
    // 3. System PATH

    // 1. Check CLI override
    if let Some(opa_path) = cli_override {
        validate_opa_binary(&opa_path)?;
        debug!("Using OPA from CLI flag: {:?}", opa_path);
        return Ok(opa_path);
    }

    // 2. Check bundled OPA
    if let Ok(current_exe) = std::env::current_exe() {
        if let Some(exe_dir) = current_exe.parent() {
            let bundled_opa = if cfg!(windows) {
                exe_dir.join("opa.exe")
            } else {
                exe_dir.join("opa")
            };

            if bundled_opa.exists() {
                if let Err(e) = validate_opa_binary(&bundled_opa) {
                    warn!("Bundled OPA failed validation: {}", e);
                } else {
                    debug!("Using bundled OPA: {:?}", bundled_opa);
                    return Ok(bundled_opa);
                }
            }
        }
    }

    // 3. Fall back to system PATH
    let system_opa = if cfg!(windows) {
        PathBuf::from("opa.exe")
    } else {
        PathBuf::from("opa")
    };

    debug!("Using OPA from system PATH");
    Ok(system_opa)
}

// NEW: Validate OPA binary before use
fn validate_opa_binary(path: &Path) -> Result<()> {
    // Must exist
    if !path.exists() {
        bail!("OPA binary does not exist: {}", path.display());
    }

    // Must be executable
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let metadata = path.metadata()?;
        let permissions = metadata.permissions();
        if permissions.mode() & 0o111 == 0 {
            bail!("OPA binary is not executable: {}", path.display());
        }
    }

    // Basic sanity check - try to get version
    let output = std::process::Command::new(path)
        .arg("version")
        .output()
        .context("Failed to execute OPA binary")?;

    if !output.status.success() {
        bail!("OPA binary failed version check: {}", path.display());
    }

    Ok(())
}
```

**Acceptance Criteria**:
- ✅ `CUPCAKE_OPA_PATH` env var removed
- ✅ `--opa-path` flag provides override
- ✅ OPA binary validated before use
- ✅ Clear error messages on invalid binary

---

### 1.4 Testing Strategy for Phase 1

#### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_memory_size_validation() {
        // Too small
        assert!(MemorySize::from_str("0MB").is_err());
        assert!(MemorySize::from_str("512KB").is_err());

        // Valid range
        assert!(MemorySize::from_str("1MB").is_ok());
        assert!(MemorySize::from_str("50MB").is_ok());
        assert!(MemorySize::from_str("100MB").is_ok());

        // Too large
        assert!(MemorySize::from_str("200MB").is_err());
    }

    #[test]
    fn test_global_config_no_env_var() {
        // Set env var (should be ignored)
        std::env::set_var("CUPCAKE_GLOBAL_CONFIG", "/tmp/evil.yml");

        // Should not use env var
        let config = load_global_config(None).unwrap();

        // Verify it didn't load /tmp/evil.yml
        // (would need to check actual config source)

        std::env::remove_var("CUPCAKE_GLOBAL_CONFIG");
    }

    #[test]
    fn test_cli_flag_takes_precedence() {
        let cli_path = PathBuf::from("/etc/cupcake/global.yml");

        // Create test config file
        // ...

        let config = load_global_config(Some(cli_path)).unwrap();
        assert!(config.is_some());
    }
}
```

#### Integration Tests
```bash
# Test that env vars are ignored
export CUPCAKE_GLOBAL_CONFIG="/tmp/malicious.yml"
export CUPCAKE_TRACE="all"
export CUPCAKE_WASM_MAX_MEMORY="0MB"

# Should use defaults, not env vars
cupcake eval < test-event.json

# Should succeed without panic (env vars ignored)

# Test CLI flags work
cupcake eval --trace=all --wasm-max-memory=50MB < test-event.json
# Should enable tracing and set memory correctly
```

---

### 1.5 Documentation Updates for Phase 1

#### Update ENVIRONMENT_VARIABLES.md

Add deprecation warnings:
```markdown
## ⚠️ DEPRECATED ENVIRONMENT VARIABLES

The following environment variables have been **REMOVED** for security reasons
as of Cupcake v0.2.0:

### `CUPCAKE_GLOBAL_CONFIG` ❌ REMOVED
**Security Risk**: HIGH - Enables config override attacks (TOB-EQTY-LAB-CUPCAKE-11)
**Replacement**: Use `--global-config=<path>` CLI flag

### `CUPCAKE_WASM_MAX_MEMORY` ❌ REMOVED
**Security Risk**: MEDIUM - Can cause policy bypass (TOB-EQTY-LAB-CUPCAKE-1)
**Replacement**: Use `--wasm-max-memory=<size>` CLI flag

### `CUPCAKE_TRACE` ❌ REMOVED
**Security Risk**: LOW - Information disclosure (TOB-EQTY-LAB-CUPCAKE-9)
**Replacement**: Use `--trace=<modules>` CLI flag

### `RUST_LOG` ❌ REMOVED
**Security Risk**: LOW - Information disclosure (TOB-EQTY-LAB-CUPCAKE-9)
**Replacement**: Use `--log-level=<level>` CLI flag

### `CUPCAKE_DEBUG_FILES` ❌ REMOVED
**Security Risk**: LOW - Information disclosure
**Replacement**: Use `--debug-files` CLI flag

### `CUPCAKE_DEBUG_ROUTING` ❌ REMOVED
**Security Risk**: LOW - Information disclosure
**Replacement**: Use `--debug-routing` CLI flag

### `CUPCAKE_OPA_PATH` ❌ REMOVED
**Security Risk**: MEDIUM - Can point to malicious binary
**Replacement**: Use `--opa-path=<path>` CLI flag

## CLI Flag Reference (Development)

**Note**: Pre-release refactor - no user migration needed.

| Old Environment Variable | New CLI Flag |
|--------------------------|--------------|
| `CUPCAKE_GLOBAL_CONFIG` | `--global-config` |
| `CUPCAKE_TRACE` | `--trace` |
| `CUPCAKE_WASM_MAX_MEMORY` | `--wasm-max-memory` |
| `RUST_LOG` | `--log-level` |
| `CUPCAKE_DEBUG_FILES` | `--debug-files` |
| `CUPCAKE_DEBUG_ROUTING` | `--debug-routing` |
| `CUPCAKE_OPA_PATH` | `--opa-path` |
```

#### Add SECURITY.md

```markdown
# Security Policy

## Threat Model

Cupcake is designed to operate in **AI agent execution environments** where:
- AI agents can manipulate command-line arguments
- AI agents can modify files (with permission)
- AI agents receive user prompts that may contain malicious instructions
- Environment variables are considered **untrusted input**

## Security Architecture

### Defense in Depth

1. **No Environment Variables for Behavior Control**
   - All runtime behavior controlled via CLI flags
   - Env vars used only for install-time configuration
   - Explicit > Implicit

2. **Input Validation**
   - All CLI inputs validated at parse time
   - Path inputs checked for traversal attempts
   - Memory limits enforced (1MB min, 100MB max)

3. **Fail-Safe Defaults**
   - Invalid input → Deny (not crash)
   - Panic → Deny all (not bypass)
   - Missing config → Safe defaults (not fail open)

4. **Command Execution Hardening**
   - No `bash -c` usage
   - Explicit Command::new() with argument arrays
   - No shell interpretation of user input

## Addressed Vulnerabilities

### v0.2.0 Security Release

This release addresses all findings from Trail of Bits security audit (September 2025):

- ✅ **TOB-EQTY-LAB-CUPCAKE-1**: WASM memory bypass (minimum enforcement)
- ✅ **TOB-EQTY-LAB-CUPCAKE-9**: Log exposure (CLI flags only)
- ✅ **TOB-EQTY-LAB-CUPCAKE-11**: Global config override (removed env var)
```

---

## Phase 2: Shell Command Hardening

**Goal**: Eliminate all shell command injection vulnerabilities
**Duration**: 1.5 weeks
**Risk**: Medium (requires careful refactor of signal/action execution)
**Addresses**: TOB-EQTY-LAB-CUPCAKE-2, 4, 8

### 2.1 Problem Analysis

#### Current Vulnerable Pattern:
```rust
// VULNERABLE - Uses bash -c with string interpolation
let output = Command::new("bash")
    .arg("-c")
    .arg(&signal_command)  // User-controlled string!
    .output()?;
```

**Attack Example**:
```yaml
signals:
  malicious:
    command: "echo safe && cat /etc/passwd && echo safe"
```

#### Root Cause:
- Signals and actions execute arbitrary shell commands
- Commands are strings that get passed to `bash -c`
- No sanitization or validation
- Shell interprets `&&`, `||`, `;`, `|`, etc.

### 2.2 Architecture Changes

#### New Signal/Action Execution Model

**Option A: Restricted Command Set** (Recommended)
```rust
/// Allowed signal/action commands (whitelist approach)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
enum SecureCommand {
    /// Execute a git command
    Git {
        args: Vec<String>,
    },
    /// Execute a file read
    Read {
        path: PathBuf,
    },
    /// Execute a custom script from trusted scripts directory
    Script {
        name: String,
        args: Vec<String>,
    },
    /// Echo a static string (no variable substitution)
    Echo {
        message: String,
    },
}

impl SecureCommand {
    /// Execute the command safely (no shell interpretation)
    fn execute(&self) -> Result<CommandOutput> {
        match self {
            SecureCommand::Git { args } => {
                let output = Command::new("git")
                    .args(args)
                    .output()?;

                Ok(CommandOutput::from_output(output))
            }
            SecureCommand::Read { path } => {
                // Validate path is within allowed directories
                validate_read_path(path)?;
                let content = std::fs::read_to_string(path)?;
                Ok(CommandOutput::success(content))
            }
            SecureCommand::Script { name, args } => {
                // Only execute scripts from .cupcake/scripts/
                let script_path = self.get_trusted_script_path(name)?;

                let output = Command::new(&script_path)
                    .args(args)
                    .output()?;

                Ok(CommandOutput::from_output(output))
            }
            SecureCommand::Echo { message } => {
                Ok(CommandOutput::success(message.clone()))
            }
        }
    }
}
```

**Guidebook YAML Format** (New):
```yaml
signals:
  git_branch:
    type: git
    args: ["rev-parse", "--abbrev-ref", "HEAD"]

  file_exists:
    type: read
    path: ".cupcake/config.yml"

  custom_check:
    type: script
    name: "check_environment"
    args: ["--strict"]

  notification:
    type: echo
    message: "Policy check completed"

actions:
  on_deny:
    - type: echo
      message: "Action denied by policy"

    - type: script
      name: "log_denial"
      args: ["--severity=high"]
```

**Benefits**:
- ✅ No shell interpretation
- ✅ Explicit command + args (no injection)
- ✅ Type-safe configuration
- ✅ Easy to audit
- ✅ Whitelist approach (deny by default)

**Option B: Argument Array Format** (Less Breaking)
```yaml
# Old (vulnerable)
signals:
  git_branch:
    command: "git rev-parse --abbrev-ref HEAD"

# New (safe)
signals:
  git_branch:
    command: "git"
    args:
      - "rev-parse"
      - "--abbrev-ref"
      - "HEAD"
```

**Recommended**: Option A (more secure, easier to validate)

### 2.3 Implementation Tasks

#### Task 2.1: Define Secure Command Types
**File**: `cupcake-core/src/engine/secure_command.rs` (NEW)
**Estimated Time**: 4 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-2, 4, 8

```rust
//! Secure command execution without shell interpretation
//!
//! This module provides safe alternatives to `bash -c` for executing
//! commands in signals and actions. All commands are executed directly
//! without shell interpretation, preventing injection attacks.

use anyhow::{bail, Context, Result};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use std::process::{Command, Output};

/// Secure command types (whitelist approach)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum SecureCommand {
    /// Execute a git command
    Git { args: Vec<String> },

    /// Read a file (with path validation)
    Read { path: PathBuf },

    /// Execute a trusted script from .cupcake/scripts/
    Script { name: String, args: Vec<String> },

    /// Echo a static message
    Echo { message: String },

    /// Test a file/directory exists
    Test { path: PathBuf, test_type: TestType },

    /// Execute a validated external command
    External {
        program: String,
        args: Vec<String>,
        /// Allowed programs (must be in PATH)
        #[serde(skip)]
        _allowed: bool,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TestType {
    Exists,
    IsFile,
    IsDirectory,
}

/// Command execution result
#[derive(Debug, Clone)]
pub struct CommandOutput {
    pub success: bool,
    pub stdout: String,
    pub stderr: String,
    pub exit_code: Option<i32>,
}

impl SecureCommand {
    /// Execute command safely (no shell interpretation)
    pub fn execute(&self, working_dir: &Path) -> Result<CommandOutput> {
        match self {
            SecureCommand::Git { args } => {
                self.execute_git(args, working_dir)
            }

            SecureCommand::Read { path } => {
                self.execute_read(path, working_dir)
            }

            SecureCommand::Script { name, args } => {
                self.execute_script(name, args, working_dir)
            }

            SecureCommand::Echo { message } => {
                Ok(CommandOutput::success(message.clone()))
            }

            SecureCommand::Test { path, test_type } => {
                self.execute_test(path, test_type, working_dir)
            }

            SecureCommand::External { program, args, .. } => {
                self.execute_external(program, args, working_dir)
            }
        }
    }

    fn execute_git(&self, args: &[String], working_dir: &Path) -> Result<CommandOutput> {
        let output = Command::new("git")
            .args(args)
            .current_dir(working_dir)
            .output()
            .context("Failed to execute git command")?;

        Ok(CommandOutput::from_output(output))
    }

    fn execute_read(&self, path: &Path, working_dir: &Path) -> Result<CommandOutput> {
        // Resolve relative to working directory
        let full_path = if path.is_absolute() {
            path.to_path_buf()
        } else {
            working_dir.join(path)
        };

        // Validate path is within working directory (prevent traversal)
        let canonical = full_path.canonicalize()
            .context("Failed to resolve path")?;

        if !canonical.starts_with(working_dir) {
            bail!(
                "Path traversal detected: {} is outside {}",
                canonical.display(),
                working_dir.display()
            );
        }

        // Read file
        let content = std::fs::read_to_string(&canonical)
            .context(format!("Failed to read file: {}", canonical.display()))?;

        Ok(CommandOutput::success(content))
    }

    fn execute_script(
        &self,
        name: &str,
        args: &[String],
        working_dir: &Path,
    ) -> Result<CommandOutput> {
        // Scripts must be in .cupcake/scripts/ directory
        let scripts_dir = working_dir.join(".cupcake").join("scripts");

        // Validate script name (no path separators)
        if name.contains('/') || name.contains('\\') {
            bail!("Invalid script name: {} (cannot contain path separators)", name);
        }

        let script_path = scripts_dir.join(name);

        // Verify script exists and is within scripts directory
        let canonical = script_path.canonicalize()
            .context(format!("Script not found: {}", name))?;

        if !canonical.starts_with(&scripts_dir) {
            bail!("Script path traversal detected: {}", name);
        }

        // Execute script (must be executable on Unix)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = canonical.metadata()?;
            if metadata.permissions().mode() & 0o111 == 0 {
                bail!("Script is not executable: {}", name);
            }
        }

        let output = Command::new(&canonical)
            .args(args)
            .current_dir(working_dir)
            .output()
            .context(format!("Failed to execute script: {}", name))?;

        Ok(CommandOutput::from_output(output))
    }

    fn execute_test(
        &self,
        path: &Path,
        test_type: &TestType,
        working_dir: &Path,
    ) -> Result<CommandOutput> {
        let full_path = if path.is_absolute() {
            path.to_path_buf()
        } else {
            working_dir.join(path)
        };

        let result = match test_type {
            TestType::Exists => full_path.exists(),
            TestType::IsFile => full_path.is_file(),
            TestType::IsDirectory => full_path.is_dir(),
        };

        if result {
            Ok(CommandOutput::success("true".to_string()))
        } else {
            Ok(CommandOutput::failure("false".to_string()))
        }
    }

    fn execute_external(
        &self,
        program: &str,
        args: &[String],
        working_dir: &Path,
    ) -> Result<CommandOutput> {
        // Whitelist of allowed external programs
        const ALLOWED_PROGRAMS: &[&str] = &[
            "git",
            "ls",
            "cat",
            "grep",
            "find",
            "test",
            // Add more as needed, carefully
        ];

        if !ALLOWED_PROGRAMS.contains(&program) {
            bail!(
                "Program '{}' is not in the allowed list. Allowed: {:?}",
                program,
                ALLOWED_PROGRAMS
            );
        }

        let output = Command::new(program)
            .args(args)
            .current_dir(working_dir)
            .output()
            .context(format!("Failed to execute {}", program))?;

        Ok(CommandOutput::from_output(output))
    }
}

impl CommandOutput {
    pub fn success(stdout: String) -> Self {
        Self {
            success: true,
            stdout,
            stderr: String::new(),
            exit_code: Some(0),
        }
    }

    pub fn failure(stderr: String) -> Self {
        Self {
            success: false,
            stdout: String::new(),
            stderr,
            exit_code: Some(1),
        }
    }

    pub fn from_output(output: Output) -> Self {
        Self {
            success: output.status.success(),
            stdout: String::from_utf8_lossy(&output.stdout).to_string(),
            stderr: String::from_utf8_lossy(&output.stderr).to_string(),
            exit_code: output.status.code(),
        }
    }
}
```

**Acceptance Criteria**:
- ✅ No shell interpretation (no `bash -c`)
- ✅ Whitelist approach for allowed commands
- ✅ Path validation prevents directory traversal
- ✅ Script execution limited to `.cupcake/scripts/`
- ✅ All inputs validated before execution

---

#### Task 2.2: Update Signal Execution
**File**: `cupcake-core/src/engine/guidebook.rs`
**Estimated Time**: 6 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-2, 4

```rust
/// Signal definition in guidebook
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    /// Secure command to execute
    #[serde(flatten)]
    pub command: SecureCommand,

    /// Timeout in seconds (optional)
    #[serde(default)]
    pub timeout_seconds: Option<u64>,

    /// Cache result for this many seconds (optional)
    #[serde(default)]
    pub cache_seconds: Option<u64>,
}

/// Execute a signal and return its output
pub async fn execute_signal(
    name: &str,
    signal: &Signal,
    working_dir: &Path,
) -> Result<SignalOutput> {
    debug!("Executing signal: {}", name);

    // Apply timeout if specified
    let timeout = signal.timeout_seconds
        .map(Duration::from_secs)
        .unwrap_or(Duration::from_secs(30)); // Default 30s

    // Execute command with timeout
    let result = tokio::time::timeout(
        timeout,
        tokio::task::spawn_blocking({
            let command = signal.command.clone();
            let working_dir = working_dir.to_path_buf();
            move || command.execute(&working_dir)
        }),
    ).await;

    match result {
        Ok(Ok(output)) => {
            if output.success {
                Ok(SignalOutput::Success(output.stdout.trim().to_string()))
            } else {
                Ok(SignalOutput::Failure {
                    exit_code: output.exit_code.unwrap_or(-1),
                    stderr: output.stderr,
                })
            }
        }
        Ok(Err(e)) => {
            warn!("Signal '{}' execution failed: {}", name, e);
            Ok(SignalOutput::Error(e.to_string()))
        }
        Err(_timeout) => {
            warn!("Signal '{}' timed out after {:?}", name, timeout);
            Ok(SignalOutput::Timeout)
        }
    }
}
```

**Format Change** (development only - no users to migrate):
```yaml
# OLD FORMAT (will no longer work)
signals:
  git_branch:
    command: "git rev-parse --abbrev-ref HEAD"

# NEW FORMAT (required)
signals:
  git_branch:
    type: git
    args: ["rev-parse", "--abbrev-ref", "HEAD"]
```

**Acceptance Criteria**:
- ✅ Old string-based commands rejected with clear error
- ✅ Only SecureCommand types accepted
- ✅ No shell execution anywhere
- ✅ Timeout protection
- ✅ Error handling preserves security (no bypass on failure)

---

#### Task 2.3: Update Action Execution
**File**: `cupcake-core/src/engine/actions.rs`
**Estimated Time**: 4 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-8

```rust
/// Action definition in guidebook
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Action {
    /// Secure command to execute
    #[serde(flatten)]
    pub command: SecureCommand,

    /// Continue on failure (default: true for actions)
    #[serde(default = "default_true")]
    pub continue_on_failure: bool,
}

/// Execute actions asynchronously (fire-and-forget)
pub fn execute_actions(
    actions: Vec<Action>,
    working_dir: PathBuf,
    event_context: String,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        for (idx, action) in actions.iter().enumerate() {
            debug!("Executing action {}/{}", idx + 1, actions.len());

            match action.command.execute(&working_dir) {
                Ok(output) => {
                    if output.success {
                        debug!("Action {} succeeded", idx + 1);
                    } else {
                        warn!(
                            "Action {} failed with exit code {}: {}",
                            idx + 1,
                            output.exit_code.unwrap_or(-1),
                            output.stderr
                        );

                        if !action.continue_on_failure {
                            error!("Action {} failed, stopping action chain", idx + 1);
                            break;
                        }
                    }
                }
                Err(e) => {
                    error!("Action {} execution error: {}", idx + 1, e);

                    if !action.continue_on_failure {
                        error!("Action {} failed, stopping action chain", idx + 1);
                        break;
                    }
                }
            }
        }

        debug!("Action execution complete");
    })
}
```

**Acceptance Criteria**:
- ✅ Actions use SecureCommand (no shell)
- ✅ Fire-and-forget maintained (async execution)
- ✅ Error handling doesn't compromise security
- ✅ continue_on_failure honored

---

#### Task 2.4: Guidebook Validation
**File**: `cupcake-core/src/engine/guidebook.rs`
**Estimated Time**: 3 hours

```rust
/// Validate guidebook configuration at load time
pub fn validate_guidebook(guidebook: &Guidebook) -> Result<()> {
    // Validate all signals
    for (name, signal) in &guidebook.signals {
        validate_signal(name, signal)
            .context(format!("Invalid signal '{}'", name))?;
    }

    // Validate all actions
    for (trigger, actions) in &guidebook.actions {
        for (idx, action) in actions.iter().enumerate() {
            validate_action(trigger, idx, action)
                .context(format!("Invalid action in trigger '{}'", trigger))?;
        }
    }

    Ok(())
}

fn validate_signal(name: &str, signal: &Signal) -> Result<()> {
    // Signal names must be valid identifiers
    if !name.chars().all(|c| c.is_alphanumeric() || c == '_') {
        bail!("Signal name must be alphanumeric with underscores: {}", name);
    }

    // Validate timeout is reasonable
    if let Some(timeout) = signal.timeout_seconds {
        if timeout > 300 {
            bail!("Signal timeout too long: {}s (max: 300s)", timeout);
        }
    }

    // Validate command
    validate_secure_command(&signal.command)?;

    Ok(())
}

fn validate_secure_command(command: &SecureCommand) -> Result<()> {
    match command {
        SecureCommand::Git { args } => {
            if args.is_empty() {
                bail!("Git command requires arguments");
            }
            // Further validation: check for dangerous flags?
            Ok(())
        }

        SecureCommand::Read { path } => {
            if path.to_str().unwrap_or("").contains("..") {
                bail!("Path cannot contain '..' segments");
            }
            Ok(())
        }

        SecureCommand::Script { name, .. } => {
            if name.contains('/') || name.contains('\\') {
                bail!("Script name cannot contain path separators");
            }
            Ok(())
        }

        SecureCommand::External { program, .. } => {
            // Validate against whitelist at load time
            const ALLOWED: &[&str] = &["git", "ls", "cat", "grep", "find", "test"];
            if !ALLOWED.contains(&program.as_str()) {
                bail!("Program '{}' is not allowed", program);
            }
            Ok(())
        }

        _ => Ok(()),
    }
}
```

**Acceptance Criteria**:
- ✅ Guidebook validated at load time
- ✅ Invalid commands rejected early
- ✅ Clear error messages guide users to fix
- ✅ No runtime surprises

---

### 2.4 Development Verification Tools

**Note**: These are for verifying the refactor in our development environment only. No user migration needed (pre-release).

#### Task 2.5: Create Verification Script
**File**: `scripts/verify_secure_commands.sh` (NEW)
**Estimated Time**: 2 hours

```python
#!/usr/bin/env python3
"""
Migrate guidebook.yml from old format (bash commands) to new format (secure commands).

Usage:
    python scripts/migrate_guidebook.py .cupcake/guidebook.yml
"""

import re
import sys
import yaml
from pathlib import Path

def migrate_command(command_str: str) -> dict:
    """Convert bash command string to SecureCommand structure."""

    # Git commands
    if command_str.startswith("git "):
        args = command_str[4:].split()
        return {"type": "git", "args": args}

    # Echo commands
    echo_match = re.match(r'echo ["\'](.+)["\']', command_str)
    if echo_match:
        return {"type": "echo", "message": echo_match.group(1)}

    # Cat/read commands
    cat_match = re.match(r'cat (.+)', command_str)
    if cat_match:
        return {"type": "read", "path": cat_match.group(1)}

    # Test commands
    test_match = re.match(r'test -([fed]) (.+)', command_str)
    if test_match:
        test_type = {
            'e': 'exists',
            'f': 'is_file',
            'd': 'is_directory'
        }[test_match.group(1)]
        return {"type": "test", "path": test_match.group(2), "test_type": test_type}

    # Complex commands or scripts - suggest manual review
    if any(op in command_str for op in ['&&', '||', '|', ';']):
        print(f"⚠️  Complex command requires manual migration: {command_str}")
        print(f"   Consider creating a script in .cupcake/scripts/")
        return {"type": "echo", "message": "MANUAL_MIGRATION_REQUIRED"}

    # Default: treat as external command (may need whitelist update)
    parts = command_str.split()
    if parts:
        return {"type": "external", "program": parts[0], "args": parts[1:]}

    return {"type": "echo", "message": "UNKNOWN_COMMAND"}

def migrate_guidebook(input_file: Path, output_file: Path = None):
    """Migrate guidebook file."""

    if output_file is None:
        output_file = input_file.with_suffix('.yml.new')

    # Load old guidebook
    with open(input_file) as f:
        guidebook = yaml.safe_load(f)

    # Migrate signals
    if 'signals' in guidebook:
        for name, signal in guidebook['signals'].items():
            if isinstance(signal, dict) and 'command' in signal:
                if isinstance(signal['command'], str):
                    # Old format: string command
                    command_str = signal['command']
                    new_command = migrate_command(command_str)

                    # Replace command with new structure
                    signal.pop('command')
                    signal.update(new_command)

    # Migrate actions
    if 'actions' in guidebook:
        for trigger, actions in guidebook['actions'].items():
            for action in actions:
                if isinstance(action, dict) and 'command' in action:
                    if isinstance(action['command'], str):
                        command_str = action['command']
                        new_command = migrate_command(command_str)

                        action.pop('command')
                        action.update(new_command)

    # Write new guidebook
    with open(output_file, 'w') as f:
        yaml.dump(guidebook, f, default_flow_style=False, sort_keys=False)

    print(f"✅ Migrated guidebook written to: {output_file}")
    print(f"⚠️  Please review the output and test thoroughly!")
    print(f"⚠️  Search for 'MANUAL_MIGRATION_REQUIRED' markers")

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python scripts/migrate_guidebook.py <guidebook.yml>")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    if not input_file.exists():
        print(f"Error: File not found: {input_file}")
        sys.exit(1)

    migrate_guidebook(input_file)
```

**Usage**:
```bash
# Migrate project guidebook
python scripts/migrate_guidebook.py .cupcake/guidebook.yml

# Review output
diff .cupcake/guidebook.yml .cupcake/guidebook.yml.new

# Test new format
cupcake eval --policy-dir .cupcake/policies < test-event.json

# If tests pass, replace old with new
mv .cupcake/guidebook.yml.new .cupcake/guidebook.yml
```

---

### 2.5 Testing Strategy for Phase 2

#### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_git_command_execution() {
        let cmd = SecureCommand::Git {
            args: vec!["status".to_string()],
        };

        let output = cmd.execute(Path::new(".")).unwrap();
        assert!(output.success || !output.success); // Either is fine
        // (git may not be in test env)
    }

    #[test]
    fn test_path_traversal_prevention() {
        let cmd = SecureCommand::Read {
            path: PathBuf::from("../../../etc/passwd"),
        };

        let result = cmd.execute(Path::new("/tmp/test"));
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("traversal"));
    }

    #[test]
    fn test_script_path_validation() {
        let cmd = SecureCommand::Script {
            name: "../evil.sh".to_string(),
            args: vec![],
        };

        let result = cmd.execute(Path::new("."));
        assert!(result.is_err());
    }

    #[test]
    fn test_no_shell_interpretation() {
        let cmd = SecureCommand::Echo {
            message: "safe && malicious".to_string(),
        };

        let output = cmd.execute(Path::new(".")).unwrap();
        assert_eq!(output.stdout, "safe && malicious");
        // Should NOT execute "malicious" command
    }
}
```

#### Integration Tests
```rust
#[tokio::test]
async fn test_signal_execution_no_injection() {
    let guidebook = r#"
signals:
  test_injection:
    type: echo
    message: "safe && cat /etc/passwd"
"#;

    let config: Guidebook = serde_yaml::from_str(guidebook).unwrap();
    let signal = config.signals.get("test_injection").unwrap();

    let output = execute_signal("test_injection", signal, Path::new("."))
        .await
        .unwrap();

    match output {
        SignalOutput::Success(s) => {
            // Should be literal string, not executed
            assert_eq!(s, "safe && cat /etc/passwd");
        }
        _ => panic!("Expected success"),
    }
}
```

---

### 2.6 Documentation Updates for Phase 2

Update `docs/user-guide/configuration/signals.md`:

```markdown
# Signals Configuration

## ⚠️ Breaking Change in v0.2.0

**Old format (REMOVED for security)**:
```yaml
signals:
  git_branch:
    command: "git rev-parse --abbrev-ref HEAD"  # ❌ Shell injection vulnerability
```

**New format (REQUIRED)**:
```yaml
signals:
  git_branch:
    type: git
    args: ["rev-parse", "--abbrev-ref", "HEAD"]  # ✅ Safe, no shell
```

## Secure Command Types

### Git Command
Execute git commands safely:
```yaml
signals:
  current_branch:
    type: git
    args: ["rev-parse", "--abbrev-ref", "HEAD"]

  repo_status:
    type: git
    args: ["status", "--porcelain"]
```

### Read File
Read file contents with path validation:
```yaml
signals:
  config_check:
    type: read
    path: ".cupcake/config.yml"
```

**Security**: Prevents directory traversal attacks.

### Execute Script
Run scripts from `.cupcake/scripts/` directory:
```yaml
signals:
  custom_check:
    type: script
    name: "environment_validator"
    args: ["--strict", "--env=prod"]
```

**Security**: Scripts must be in trusted directory.

### Test Path
Test file/directory existence:
```yaml
signals:
  dockerfile_exists:
    type: test
    path: "Dockerfile"
    test_type: is_file
```

### Echo Message
Output static message:
```yaml
signals:
  notification:
    type: echo
    message: "Policy check completed"
```

## Security Rationale

**Why we removed shell commands**:
- TOB-EQTY-LAB-CUPCAKE-2: Signal bash injection (HIGH severity)
- TOB-EQTY-LAB-CUPCAKE-4: Signal command injection (HIGH severity)
- TOB-EQTY-LAB-CUPCAKE-8: Action command injection (HIGH severity)

Shell commands with `bash -c` allowed arbitrary code execution through
command injection. The new format eliminates shell interpretation entirely.
```

---

## Phase 3: Trust System Improvements

**Goal**: Harden trust manifest validation and script execution
**Duration**: 1 week
**Risk**: Low (mostly validation improvements)
**Addresses**: TOB-EQTY-LAB-CUPCAKE-3, 6

### 3.1 Problem Analysis

#### Finding #3: Directory Traversal in Trust System
```yaml
# Vulnerable - can execute scripts outside .cupcake/scripts/
trusted_scripts:
  - "../../../tmp/evil.sh"
```

#### Finding #6: Trust Manifest Can Be Modified
- AI agent can modify `manifest.json`
- HMAC verification may be weak in test mode
- No protection against manifest tampering

### 3.2 Implementation Tasks

#### Task 3.1: Script Path Validation
**File**: `cupcake-core/src/trust/mod.rs`
**Estimated Time**: 3 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-3

```rust
/// Validate script path before execution
fn validate_script_path(script_path: &Path, scripts_dir: &Path) -> Result<()> {
    // Must be within .cupcake/scripts/
    let canonical = script_path.canonicalize()
        .context("Script path does not exist")?;

    let canonical_scripts_dir = scripts_dir.canonicalize()
        .context("Scripts directory does not exist")?;

    if !canonical.starts_with(&canonical_scripts_dir) {
        bail!(
            "Script path traversal detected: {} is outside {}",
            canonical.display(),
            canonical_scripts_dir.display()
        );
    }

    // Must be a regular file
    if !canonical.is_file() {
        bail!("Script path must be a regular file: {}", canonical.display());
    }

    // On Unix, must be executable
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let metadata = canonical.metadata()?;
        if metadata.permissions().mode() & 0o111 == 0 {
            bail!("Script is not executable: {}", canonical.display());
        }
    }

    Ok(())
}
```

**Acceptance Criteria**:
- ✅ Path traversal prevented
- ✅ Symlinks resolved and validated
- ✅ Only files in `.cupcake/scripts/` executable

---

#### Task 3.2: Manifest Integrity Checks
**File**: `cupcake-core/src/trust/manifest.rs`
**Estimated Time**: 4 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-6

```rust
/// Enhanced manifest validation
pub fn validate_manifest(manifest: &TrustManifest) -> Result<()> {
    // Check HMAC is present
    if manifest.hmac.is_empty() {
        bail!("Trust manifest missing HMAC signature");
    }

    // Validate all script paths
    for script_path in &manifest.trusted_scripts {
        validate_manifest_script_path(script_path)?;
    }

    // Check timestamp is not in future
    if manifest.timestamp > SystemTime::now() {
        bail!("Trust manifest timestamp is in the future");
    }

    // Check timestamp is not too old (7 days)
    let max_age = Duration::from_secs(7 * 24 * 60 * 60);
    if manifest.timestamp + max_age < SystemTime::now() {
        warn!("Trust manifest is older than 7 days, consider refreshing");
    }

    Ok(())
}

fn validate_manifest_script_path(path: &str) -> Result<()> {
    // Must be relative path
    if path.starts_with('/') || path.starts_with('\\') {
        bail!("Script path must be relative: {}", path);
    }

    // Must not contain path traversal
    if path.contains("..") {
        bail!("Script path cannot contain '..': {}", path);
    }

    // Must not contain absolute path components
    #[cfg(windows)]
    if path.contains(':') {
        bail!("Script path cannot contain drive letters: {}", path);
    }

    Ok(())
}

/// Verify HMAC is not using deterministic test mode in production
pub fn check_production_hmac_security() -> Result<()> {
    #[cfg(feature = "deterministic-tests")]
    {
        // This should NEVER happen in production builds
        bail!(
            "CRITICAL: deterministic-tests feature is enabled in production! \
             This makes HMAC keys predictable and trust manifest forgeable. \
             Rebuild without --features deterministic-tests."
        );
    }

    Ok(())
}
```

**Acceptance Criteria**:
- ✅ Path traversal in manifest rejected
- ✅ Absolute paths rejected
- ✅ HMAC signature required
- ✅ Timestamp validation
- ✅ Production check for deterministic-tests feature

---

#### Task 3.3: Add Runtime Security Check
**File**: `cupcake-cli/src/main.rs`
**Estimated Time**: 1 hour

```rust
#[tokio::main]
async fn main() -> Result<()> {
    // CRITICAL: Verify we're not using test features in production
    cupcake_core::trust::check_production_hmac_security()
        .context("Security validation failed")?;

    // Initialize tracing
    initialize_tracing(&cli.trace, cli.log_level);

    // ... rest of main
}
```

**Acceptance Criteria**:
- ✅ Production builds fail fast if test features enabled
- ✅ Clear error message guides user to fix
- ✅ Cannot accidentally deploy insecure build

---

### 3.3 Testing for Phase 3

```rust
#[test]
fn test_manifest_path_traversal_rejected() {
    let manifest = TrustManifest {
        trusted_scripts: vec!["../../../etc/passwd".to_string()],
        // ... other fields
    };

    let result = validate_manifest(&manifest);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains(".."));
}

#[test]
#[cfg(feature = "deterministic-tests")]
fn test_production_security_check_fails_in_test_mode() {
    let result = check_production_hmac_security();
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("deterministic-tests"));
}

#[test]
#[cfg(not(feature = "deterministic-tests"))]
fn test_production_security_check_passes() {
    let result = check_production_hmac_security();
    assert!(result.is_ok());
}
```

---

## Phase 4: Policy System Hardening

**Goal**: Fix policy override and interaction issues
**Duration**: 1 week
**Risk**: Medium (touches core evaluation logic)
**Addresses**: TOB-EQTY-LAB-CUPCAKE-5, 10

### 4.1 Problem Analysis

#### Finding #5: Policy Namespace Override
- Global policies can override project policies using same package name
- No visibility into which policy is being used

#### Finding #10: Global Deny Overrides Ask
- Global `deny` completely blocks local `ask`
- User loses ability to make decisions

### 4.2 Implementation Tasks

#### Task 4.1: Policy Namespace Isolation
**File**: `cupcake-core/src/engine/compiler.rs`
**Estimated Time**: 4 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-5

```rust
/// Ensure global and project policies use different namespaces
pub async fn compile_policies_with_isolation(
    project_policies: &[PolicyUnit],
    global_policies: &[PolicyUnit],
) -> Result<(Vec<u8>, Vec<u8>)> {
    // Project policies: cupcake.project.policies.*
    let project_wasm = compile_policies_with_namespace(
        project_policies,
        "cupcake.project.system"
    ).await?;

    // Global policies: cupcake.global.policies.*
    let global_wasm = compile_policies_with_namespace(
        global_policies,
        "cupcake.global.system"
    ).await?;

    Ok((project_wasm, global_wasm))
}

/// Transform policy package names to ensure isolation
fn ensure_namespace_isolation(
    policies: &[PolicyUnit],
    namespace_prefix: &str,
) -> Vec<PolicyUnit> {
    policies.iter().map(|policy| {
        let mut isolated_policy = policy.clone();

        // Rewrite package name if needed
        if !isolated_policy.package_name.starts_with(namespace_prefix) {
            let new_package = format!(
                "{}.{}",
                namespace_prefix,
                isolated_policy.package_name
                    .strip_prefix("cupcake.")
                    .unwrap_or(&isolated_policy.package_name)
            );

            isolated_policy.package_name = new_package;
        }

        isolated_policy
    }).collect()
}
```

**Acceptance Criteria**:
- ✅ Project policies always in `cupcake.project.*` namespace
- ✅ Global policies always in `cupcake.global.*` namespace
- ✅ No namespace collision possible
- ✅ Both policy sets can coexist

---

#### Task 4.2: Policy Decision Priority Clarification
**File**: `cupcake-core/src/engine/synthesis.rs`
**Estimated Time**: 6 hours
**Addresses**: TOB-EQTY-LAB-CUPCAKE-10

```rust
/// Policy decision synthesis with explicit priority and user choice preservation
pub fn synthesize_decisions(
    project_decisions: DecisionSet,
    global_decisions: DecisionSet,
    config: &SynthesisConfig,
) -> SynthesisResult {
    // Priority order:
    // 1. Global halts (absolute stop, no override)
    // 2. Global denies (organizational policy, no override)
    // 3. Project asks (user choice respected UNLESS global denied)
    // 4. Project denies (project-level policy)
    // 5. Global asks (organizational guidance)
    // 6. Project allows (explicit project permission)
    // 7. Default deny (fail closed)

    // Check global halts first (highest priority)
    if !global_decisions.halts.is_empty() {
        return SynthesisResult::Halt {
            reason: global_decisions.halts[0].reason.clone(),
            source: PolicySource::Global,
        };
    }

    // Check global denies
    if !global_decisions.denials.is_empty() {
        // IMPORTANT: Global deny blocks everything, including project asks
        // This is organizational policy enforcement
        return SynthesisResult::Deny {
            reason: global_decisions.denials[0].reason.clone(),
            source: PolicySource::Global,
            blocked_asks: project_decisions.asks.clone(),  // Record what was blocked
        };
    }

    // Project asks (USER CHOICE - only if not blocked by global)
    if !project_decisions.asks.is_empty() {
        return SynthesisResult::Ask {
            questions: project_decisions.asks.clone(),
            source: PolicySource::Project,
            advisory: global_decisions.asks.clone(),  // Global asks as advice
        };
    }

    // Project denies
    if !project_decisions.denials.is_empty() {
        return SynthesisResult::Deny {
            reason: project_decisions.denials[0].reason.clone(),
            source: PolicySource::Project,
            blocked_asks: vec![],
        };
    }

    // Global asks (advisory only at this point)
    if !global_decisions.asks.is_empty() {
        return SynthesisResult::Ask {
            questions: global_decisions.asks.clone(),
            source: PolicySource::Global,
            advisory: vec![],
        };
    }

    // Project explicit allows
    if !project_decisions.allow_overrides.is_empty() {
        return SynthesisResult::Allow {
            reason: Some("Project policy explicitly allows this action".to_string()),
            source: PolicySource::Project,
        };
    }

    // Default: deny (fail closed)
    SynthesisResult::Deny {
        reason: "No policy explicitly allows this action (default deny)".to_string(),
        source: PolicySource::Default,
        blocked_asks: vec![],
    }
}

#[derive(Debug)]
pub enum PolicySource {
    Global,
    Project,
    Default,
}

/// Enhanced synthesis result with transparency
#[derive(Debug)]
pub enum SynthesisResult {
    Halt {
        reason: String,
        source: PolicySource,
    },
    Deny {
        reason: String,
        source: PolicySource,
        /// Records any project-level asks that were blocked by this deny
        blocked_asks: Vec<AskDecision>,
    },
    Ask {
        questions: Vec<AskDecision>,
        source: PolicySource,
        /// Advisory asks from other policy level (shown as guidance)
        advisory: Vec<AskDecision>,
    },
    Allow {
        reason: Option<String>,
        source: PolicySource,
    },
}
```

**Key Changes**:
- ✅ Explicit priority order documented
- ✅ Blocked asks recorded (transparency)
- ✅ Policy source tracked (global vs project)
- ✅ Advisory asks separated from blocking asks

**User-Facing Impact**:
```json
{
  "decision": "deny",
  "reason": "Company policy blocks main branch commits",
  "source": "global",
  "blocked_project_asks": [
    {
      "question": "Allow commit to main with review?",
      "source": "project"
    }
  ],
  "note": "Contact your security team to discuss exceptions"
}
```

**Acceptance Criteria**:
- ✅ Global deny documented as blocking asks
- ✅ User informed why their ask was blocked
- ✅ Source of decision clear (global vs project)
- ✅ Maintains security (global policy enforced)

---

### 4.3 Documentation for Phase 4

Add to `docs/user-guide/policies/POLICIES.md`:

```markdown
## Policy Priority and Interaction

### Global vs Project Policies

**Namespace Isolation** (v0.2.0+):
- Project policies: `cupcake.project.policies.*`
- Global policies: `cupcake.global.policies.*`
- No namespace collision possible

**Decision Priority**:

1. **Global Halt** - Immediate stop, no override possible
2. **Global Deny** - Organizational policy, blocks all project decisions
3. **Project Ask** - User choice (unless blocked by global deny)
4. **Project Deny** - Project-level policy
5. **Global Ask** - Advisory guidance
6. **Project Allow** - Explicit project permission
7. **Default Deny** - Fail closed if no policy matches

### Global Deny Blocks Project Ask

**Scenario**: Project wants to ask user, but global policy denies.

**Project Policy**:
```rego
ask contains decision if {
    input.tool_input.command == "git push origin main"
    decision := {
        "question": "Allow push to main branch?",
        "reason": "Main branch requires review",
    }
}
```

**Global Policy**:
```rego
deny contains decision if {
    input.tool_input.command == "git push origin main"
    decision := {
        "reason": "Company policy blocks direct main branch commits",
        "severity": "HIGH",
    }
}
```

**Result**: Global deny wins, user not asked.

**Response**:
```json
{
  "decision": "deny",
  "reason": "Company policy blocks direct main branch commits",
  "source": "global",
  "blocked_asks": [
    "Project wanted to ask: Allow push to main branch?"
  ]
}
```

**Rationale**: This is **intentional** for organizational policy enforcement.
If you need exceptions, update the global policy or contact your admin.

### Best Practices

- **Use global for organizational mandates** (security, compliance)
- **Use project for team-specific workflows** (local conventions)
- **Document global policies clearly** (users need to know constraints)
- **Provide escalation path** (how to request policy exceptions)
```

---

## Phase 5: Testing & Validation

**Goal**: Comprehensive testing of all security fixes
**Duration**: 1 week
**Risk**: Low
**Addresses**: All findings validation

### 5.1 Security Test Suite

Create `cupcake-core/tests/security_tests.rs`:

```rust
//! Security-focused integration tests
//!
//! Tests all Trail of Bits findings are fixed

use cupcake_core::*;

// ============================================================================
// TOB-EQTY-LAB-CUPCAKE-1: WASM Memory Bypass
// ============================================================================

#[test]
fn test_cupcake_1_wasm_memory_minimum_enforced() {
    // Attempt to set memory to 0MB (should be rejected at CLI parse)
    let result = MemorySize::from_str("0MB");
    assert!(result.is_err());
    assert!(result.unwrap_err().contains("too small"));

    // Verify minimum is 1MB
    let result = MemorySize::from_str("1MB");
    assert!(result.is_ok());
}

#[test]
fn test_cupcake_1_no_panic_on_zero_memory() {
    // Even if somehow zero gets through, should not panic
    let memory = MemorySize { bytes: 0 };
    let config = get_memory_config(memory);

    // Should clamp to minimum, not panic
    assert!(config.1.is_some());
    assert!(config.1.unwrap() > 0);
}

// ============================================================================
// TOB-EQTY-LAB-CUPCAKE-2, 4, 8: Shell Injection
// ============================================================================

#[tokio::test]
async fn test_cupcake_2_signal_no_shell_injection() {
    let guidebook = r#"
signals:
  injection_attempt:
    type: echo
    message: "safe && cat /etc/passwd"
"#;

    let config: Guidebook = serde_yaml::from_str(guidebook).unwrap();
    let signal = config.signals.get("injection_attempt").unwrap();

    let output = execute_signal("injection_attempt", signal, Path::new("."))
        .await
        .unwrap();

    // Should be literal string, not execute cat
    match output {
        SignalOutput::Success(s) => {
            assert_eq!(s, "safe && cat /etc/passwd");
            // Verify /etc/passwd not actually read
        }
        _ => panic!("Expected success with literal string"),
    }
}

#[test]
fn test_cupcake_4_old_format_rejected() {
    // Old string-based command format should be rejected
    let guidebook = r#"
signals:
  old_format:
    command: "git rev-parse --abbrev-ref HEAD"
"#;

    let result: Result<Guidebook, _> = serde_yaml::from_str(guidebook);
    assert!(result.is_err());
}

// ============================================================================
// TOB-EQTY-LAB-CUPCAKE-3: Trust Path Traversal
// ============================================================================

#[test]
fn test_cupcake_3_trust_path_traversal_blocked() {
    let script_path = Path::new("../../../etc/passwd");
    let scripts_dir = Path::new(".cupcake/scripts");

    let result = validate_script_path(script_path, scripts_dir);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("traversal"));
}

// ============================================================================
// TOB-EQTY-LAB-CUPCAKE-5: Policy Namespace Collision
// ============================================================================

#[tokio::test]
async fn test_cupcake_5_namespace_isolation() {
    // Create policies with same package name
    let project_policy = PolicyUnit {
        package_name: "cupcake.policies.test".to_string(),
        // ...
    };

    let global_policy = PolicyUnit {
        package_name: "cupcake.policies.test".to_string(),
        // ...
    };

    // After compilation, should be in different namespaces
    let (project_wasm, global_wasm) = compile_policies_with_isolation(
        &[project_policy],
        &[global_policy],
    ).await.unwrap();

    // Verify namespaces are different
    // (Would need to inspect WASM or eval results)
}

// ============================================================================
// TOB-EQTY-LAB-CUPCAKE-6: Trust Manifest Validation
// ============================================================================

#[test]
fn test_cupcake_6_manifest_timestamp_validation() {
    let mut manifest = TrustManifest::default();

    // Future timestamp should be rejected
    manifest.timestamp = SystemTime::now() + Duration::from_secs(3600);

    let result = validate_manifest(&manifest);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("future"));
}

#[test]
#[cfg(feature = "deterministic-tests")]
fn test_cupcake_6_production_check_fails_with_test_feature() {
    // This test runs with deterministic-tests feature
    // Production check should fail
    let result = check_production_hmac_security();
    assert!(result.is_err());
}

// ============================================================================
// TOB-EQTY-LAB-CUPCAKE-9: Log Exposure
// ============================================================================

#[test]
fn test_cupcake_9_no_env_var_logging() {
    // Set env vars (should be ignored)
    std::env::set_var("CUPCAKE_TRACE", "all");
    std::env::set_var("RUST_LOG", "trace");

    // Initialize tracing with CLI args (should not use env vars)
    initialize_tracing(&[], LogLevel::Info);

    // Verify env vars were not used
    // (Would need to check actual log level, tricky to test)

    std::env::remove_var("CUPCAKE_TRACE");
    std::env::remove_var("RUST_LOG");
}

// ============================================================================
// TOB-EQTY-LAB-CUPCAKE-10: Global Deny Blocks Ask
// ============================================================================

#[test]
fn test_cupcake_10_global_deny_documented() {
    let global_decisions = DecisionSet {
        denials: vec![Decision {
            reason: "Global policy blocks this".to_string(),
            severity: Severity::High,
        }],
        ..Default::default()
    };

    let project_decisions = DecisionSet {
        asks: vec![AskDecision {
            question: "Allow this action?".to_string(),
            reason: "Project wants user input".to_string(),
        }],
        ..Default::default()
    };

    let result = synthesize_decisions(
        project_decisions,
        global_decisions,
        &SynthesisConfig::default(),
    );

    match result {
        SynthesisResult::Deny { blocked_asks, .. } => {
            // Verify ask was recorded as blocked
            assert_eq!(blocked_asks.len(), 1);
            assert!(blocked_asks[0].question.contains("Allow this action?"));
        }
        _ => panic!("Expected deny with blocked asks"),
    }
}

// ============================================================================
// TOB-EQTY-LAB-CUPCAKE-11: Global Config Override
// ============================================================================

#[test]
fn test_cupcake_11_no_env_var_global_config() {
    // Set env var (should be ignored)
    std::env::set_var("CUPCAKE_GLOBAL_CONFIG", "/tmp/evil.yml");

    // Load config without CLI override
    let config = load_global_config(None).unwrap();

    // Verify it did NOT load from env var
    // (Would need to check config source, exact test depends on impl)

    std::env::remove_var("CUPCAKE_GLOBAL_CONFIG");
}

#[test]
fn test_cupcake_11_cli_flag_validated() {
    // Absolute path required
    let result = load_global_config(Some(PathBuf::from("relative/path.yml")));
    assert!(result.is_err());

    // File must exist
    let result = load_global_config(Some(PathBuf::from("/nonexistent/config.yml")));
    assert!(result.is_err());

    // Must be .yml file
    let result = load_global_config(Some(PathBuf::from("/tmp/evil.txt")));
    assert!(result.is_err());
}
```

### 5.2 Penetration Testing Scenarios

Document in `docs/security/PENETRATION_TESTING.md`:

```markdown
# Security Penetration Testing Scenarios

## Test All Trail of Bits Findings

### CUPCAKE-1: WASM Memory Bypass

**Attack**: Try to set memory to 0MB to cause panic
```bash
cupcake eval --wasm-max-memory=0MB < event.json
```

**Expected**: CLI parse error, clear message about minimum
**Actual**: ✅ "Memory size too small: 0MB. Minimum is 1MB"

---

### CUPCAKE-2: Signal Bash Injection

**Attack**: Inject command via guidebook signal
```yaml
signals:
  malicious:
    type: echo
    message: "safe && rm -rf /"
```

**Expected**: Literal string output, no command execution
**Actual**: ✅ Outputs "safe && rm -rf /" as text

---

(Continue for all 11 findings...)
```

---

## Implementation Timeline

### Week 1: Phase 1 (Env Var Elimination)
- **Day 1-2**: Tasks 1.1-1.2 (CLI flags, global config)
- **Day 3**: Tasks 1.3-1.4 (WASM memory, tracing)
- **Day 4**: Tasks 1.5-1.6 (debug flags, OPA path)
- **Day 5**: Testing and documentation

**Deliverable**: No env vars for behavior control

---

### Week 2-3: Phase 2 (Shell Command Hardening)
- **Day 1-2**: Task 2.1 (SecureCommand types)
- **Day 3-4**: Task 2.2 (Signal execution)
- **Day 5**: Task 2.3 (Action execution)
- **Week 2, Day 6-7**: Task 2.4 (Validation)
- **Week 3, Day 1-2**: Task 2.5 (Migration tool)
- **Week 3, Day 3-5**: Testing and documentation

**Deliverable**: No shell injection vulnerabilities

---

### Week 4: Phase 3 (Trust System)
- **Day 1-2**: Task 3.1 (Script path validation)
- **Day 3-4**: Task 3.2 (Manifest integrity)
- **Day 5**: Testing and documentation

**Deliverable**: Hardened trust system

---

### Week 5: Phase 4 (Policy System)
- **Day 1-2**: Task 4.1 (Namespace isolation)
- **Day 3-5**: Task 4.2 (Decision priority)

**Deliverable**: Policy interaction improvements

---

### Week 6: Phase 5 (Testing)
- **Day 1-3**: Security test suite
- **Day 4**: Penetration testing
- **Day 5**: Documentation review and sign-off

**Deliverable**: Comprehensive security validation

---

## Success Criteria

### Security Metrics

- ✅ All 11 Trail of Bits findings addressed
- ✅ No environment variables control runtime behavior
- ✅ Zero shell command injection points
- ✅ All path inputs validated
- ✅ Trust system hardened
- ✅ Policy priority documented and tested

### Code Quality

- ✅ 100% test coverage for security-critical code
- ✅ All security tests passing
- ✅ Penetration tests fail safely
- ✅ Clear error messages guide users

### Documentation

- ✅ Migration guide for all breaking changes
- ✅ Security rationale documented
- ✅ Updated user guides
- ✅ SECURITY.md comprehensive

### User Experience

- ✅ Clear CLI flags replace env vars
- ✅ Migration tools provided
- ✅ Error messages helpful
- ✅ No silent security failures

---

## Risk Mitigation

### Technical Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Breaking changes cause user friction | High | Medium | Provide migration tools, clear docs |
| Performance regression | Low | Low | Benchmark before/after |
| New bugs introduced | Medium | Medium | Comprehensive test suite |
| Incomplete migration | Low | High | Security test suite validates all fixes |

### Project Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Timeline overrun | Medium | Low | Phased approach allows partial delivery |
| Resource availability | Low | Medium | Clear task breakdown enables parallelization |
| Scope creep | Low | Medium | Stick to ToB findings, defer enhancements |

---

## Rollout Strategy

### Version 0.2.0 (Breaking Changes)

**Pre-Release**:
1. Beta release for testing (0.2.0-beta.1)
2. Migration tool testing with real configs
3. Documentation review
4. Security audit of fixes

**Release**:
1. Security advisory published (CVE if applicable)
2. Release notes with migration guide
3. Migration tool available
4. Updated installation instructions

**Post-Release**:
1. Monitor for issues
2. Provide migration support
3. Address any edge cases
4. Backport critical fixes to 0.1.x (if needed)

---

## Appendices

### Appendix A: Environment Variables - Full Removal Matrix

| Variable | Phase | Task | Replacement | ToB Finding |
|----------|-------|------|-------------|-------------|
| CUPCAKE_GLOBAL_CONFIG | 1 | 1.2 | --global-config | CUPCAKE-11 |
| CUPCAKE_WASM_MAX_MEMORY | 1 | 1.3 | --wasm-max-memory | CUPCAKE-1 |
| CUPCAKE_TRACE | 1 | 1.4 | --trace | CUPCAKE-9 |
| RUST_LOG | 1 | 1.4 | --log-level | CUPCAKE-9 |
| CUPCAKE_DEBUG_FILES | 1 | 1.5 | --debug-files | CUPCAKE-9 |
| CUPCAKE_DEBUG_ROUTING | 1 | 1.5 | --debug-routing | CUPCAKE-9 |
| CUPCAKE_OPA_PATH | 1 | 1.6 | --opa-path | (preventive) |

### Appendix B: Command Injection - Fix Matrix

| Location | Current | New | ToB Finding |
|----------|---------|-----|-------------|
| Signal execution | `bash -c "$cmd"` | SecureCommand | CUPCAKE-2, 4 |
| Action execution | `bash -c "$cmd"` | SecureCommand | CUPCAKE-8 |
| Trust scripts | Direct exec | Path validation | CUPCAKE-3 |

### Appendix C: Testing Checklist

- [ ] CUPCAKE-1: Cannot set WASM memory to 0MB
- [ ] CUPCAKE-2: Signal bash injection blocked
- [ ] CUPCAKE-3: Trust path traversal blocked
- [ ] CUPCAKE-4: Signal command injection blocked
- [ ] CUPCAKE-5: Namespace collision prevented
- [ ] CUPCAKE-6: Manifest validation enforced
- [ ] CUPCAKE-7: (Informational - no test required)
- [ ] CUPCAKE-8: Action command injection blocked
- [ ] CUPCAKE-9: Env vars ignored for logging
- [ ] CUPCAKE-10: Global deny blocks ask (documented)
- [ ] CUPCAKE-11: Global config env var removed

### Appendix D: Documentation Updates Required

- [ ] ENVIRONMENT_VARIABLES.md - Add deprecation warnings
- [ ] SECURITY.md - Create with threat model
- [ ] docs/user-guide/configuration/signals.md - Update format
- [ ] docs/user-guide/configuration/actions.md - Update format
- [ ] docs/user-guide/policies/POLICIES.md - Add priority docs
- [ ] docs/development/DEVELOPMENT.md - Update test instructions
- [ ] README.md - Update quick start examples
- [ ] CHANGELOG.md - Document all breaking changes

---

**Action Plan Version**: 1.0
**Last Updated**: 2025-10-06
**Status**: Ready for Review
**Next Step**: Stakeholder approval to begin Phase 1
