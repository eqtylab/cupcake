This document provides a comprehensive guide to the architecture and implementation of "Cupcake," a Rust-based host application designed to enforce enterprise policies on Claude Code hooks using OPA/Rego compiled to WebAssembly (WASM).

This design addresses the complexities of high-performance evaluation, the integration of external context (Signals), and the precise mapping of policy decisions to the Claude Code Hooks API semantics.

### 1. Architecture Overview and Philosophy

Cupcake acts as the secure runtime and orchestrator for policy execution. It is designed for speed, security, and scalability in enterprise environments.

#### The Hybrid Model: Rust Orchestration and Rego Evaluation

A critical design decision is where the "intelligence layer" (decision synthesis) resides. While it could be implemented entirely in Rego, an optimized, enterprise-grade system benefits from a **Hybrid Model**.

**The Role of Rego (WASM):**

1.  **Policy Definition:** Declaratively defining conditions under which an action should be controlled (under the `cupcake.policies.*` hierarchy).
2.  **Metadata Declaration:** Specifying the required inputs (tools, events, signals) for optimization and routing.
3.  **Aggregation:** Evaluating individual policies against the input and aggregating _all_ resulting decisions across the entire policy hierarchy (e.g., finding every `deny` rule that fired).

**The Role of Rust (Cupcake Host):**

1.  **Initialization & Indexing:** Loading WASM modules and building an optimized routing table based on metadata (O(1) lookup).
2.  **Signal Gathering (I/O):** Efficiently fetching external context required by the policies.
3.  **WASM Orchestration:** Managing the WASM runtime and execution.
4.  **Decision Synthesis (The Intelligence Layer):** _Interpreting_ the aggregated decisions from Rego, prioritizing them (e.g., a `halt` overrides an `allow`), and formatting the final, precise JSON required by the Claude Code Hooks API.

**Why this hybrid approach?**
This model leverages the strengths of both platforms. OPA/Rego excels at evaluating and aggregating declarative rules across a complex hierarchy. Rust excels at performance, I/O (fetching signals), and handling the complex, application-specific logic required to map decisions to the nuanced Claude Code API semantics.

### 2. The Cupcake Pipeline: End-to-End Flow

This outlines the lifecycle of a single Claude Code event as it passes through Cupcake.

#### Phase 1: Initialization and Indexing (Rust)

At startup, Cupcake performs critical optimization steps.

1.  **Load Bundles:** Cupcake loads all policy bundles (compiled WASM files and associated metadata).
2.  **Metadata Parsing:** Cupcake parses the OPA metadata associated with every rule, specifically looking at the `custom.routing` directives (See Section 3.2).
3.  **Index Creation:** Cupcake builds an in-memory routing index (e.g., a Rust HashMap). This transforms policy evaluation from an O(n) scan of all policies to an O(1) lookup of relevant policies.

_Conceptual Index:_

```
(Event: PreToolUse, Tool: Bash) -> [
    { PolicyID: "SEC-001", RequiredSignals: ["environment", "user_risk"] },
    { PolicyID: "COMP-005", RequiredSignals: ["repository_sensitivity"] }
]
```

#### Phase 2: Event Reception and Routing (Rust)

1.  **Reception:** Claude Code triggers an event (e.g., `PreToolUse` for the `Bash` tool) and sends the JSON payload to Cupcake via STDIN.
2.  **Routing:** Cupcake uses the `hook_event_name` and `tool_name` as keys into the Index to identify the subset of relevant policies.

#### Phase 3: Signal Enrichment (Rust)

Signals provide essential external context (e.g., Is this production? Is the user an admin?).

1.  **Identify Required Signals:** Cupcake aggregates the `RequiredSignals` from the metadata of the _matched policies_ identified in Phase 2.
2.  **Optimized Fetching:** Cupcake concurrently fetches _only_ the necessary signals from external systems (APIs, databases). If no matched policies require signals, this step is skipped.

#### Phase 4: WASM Evaluation (Rego)

1.  **Input Construction:** Cupcake merges the raw event data and the fetched signals into a unified input document.

```json
{
  "event": {
    // Raw data from Claude Code Hook
    "hook_event_name": "PreToolUse",
    "tool_name": "Bash",
    "tool_input": { "command": "curl https://evil.com" }
  },
  "signals": {
    // Enriched context fetched by Cupcake
    "environment": "production",
    "user_risk": 85
  }
}
```

2.  **WASM Invocation:** Cupcake injects the input into the WASM module and invokes the standardized aggregation entrypoint (`cupcake.system.evaluate`).
3.  **Evaluation and Aggregation:** The Rego policies evaluate the input. The aggregation layer collects all resulting "Decision Objects" (see Section 3.1) and returns a standardized "Decision Set" to the Rust host.

_Example Decision Set (WASM Output):_

```json
{
  "halts": [],
  "denials": [
    {
      "reason": "[SEC-001] Network egress forbidden in production.",
      "severity": "HIGH",
      "rule_id": "SEC-001"
    }
  ],
  "asks": []
  // ... other verbs
}
```

#### Phase 5: Decision Synthesis and Response (Rust)

The Intelligence Layer in Rust analyzes the Decision Set.

1.  **Prioritization:** Applies a strict hierarchy (Halt > Deny/Block > Ask > Allow).
2.  **Formatting:** Determines the correct Claude Code Hooks API response based on the highest priority decision _and_ the specific `hook_event_name` (see Section 4).
3.  **Response & Auditing:** The final JSON response is printed to STDOUT for Claude Code to consume, and the full Decision Set is logged for auditing.

_Example Final Output (Claude API Compliant):_

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "Action blocked by policy:\n[SEC-001] Network egress forbidden in production."
  }
}
```

### 3. The Rego Format: Policies, Verbs, and Metadata

We use modern Rego v1.0 syntax (`if`, `contains`) within the `cupcake.policies.<domain>.<focus>` hierarchy.

#### 3.1. Decision Verbs (The Policy Interface)

Policy authors use standardized, multi-value rules (partial sets) called "Decision Verbs." When a condition is met, the rule contributes a "Decision Object" to the set using `contains`.

| Verb (Set Name)  | Description                                                            |
| :--------------- | :--------------------------------------------------------------------- |
| `halt`           | Immediate cessation of the entire flow. Highest priority.              |
| `deny`           | Prevent an action on policy grounds (Primarily PreToolUse).            |
| `block`          | Halt progression or block input (PostToolUse, Stop, UserPromptSubmit). |
| `ask`            | Force user confirmation (Primarily PreToolUse).                        |
| `allow_override` | Explicitly bypass default permissions.                                 |
| `add_context`    | Inject context or guidelines (UserPromptSubmit, SessionStart).         |

**Clarification on `halt`:** The Claude Code specification supports a global control field: `"continue": false`. The `halt` verb instructs the Cupcake host to output this field, which stops the entire Claude Code flow immediately after the hook execution.

#### 3.2. Metadata and Host Optimization

Metadata is crucial for enabling the Rust host to perform indexing and intelligent signal fetching _before_ evaluation.

```rego
# METADATA
# scope: rule
# title: Policy Title
# authors: ["Security Team"]
# custom:
#   severity: critical
#   id: CC-SEC-101
#   # --- Optimization Directives for Cupcake (Host-Side Indexing) ---
#   routing:
#     required_events: ["PreToolUse"]
#     required_tools: ["Bash", "WebFetch"]
#     # Declares the dependency on these signals for optimized fetching
#     required_signals: ["environment", "user_risk"]
```

#### 3.3. Example Policy (Using Signals)

```rego
package cupcake.policies.security.environment_control

import future.keywords.if
import future.keywords.contains

# METADATA
# (As defined in 3.2 above, requesting 'environment' and 'user_risk')

# This rule contributes to the 'deny' set if conditions are met.
deny contains decision if {
    # 1. Check the signals (fetched by Cupcake)
    input.signals.environment == "production"
    input.signals.user_risk > 80

    # 2. Analyze the tool input (Example for Bash)
    input.event.tool_name == "Bash"
    contains(input.event.tool_input.command, "curl")

    # 3. Generate the standardized Decision Object
    meta := rego.metadata.rule()
    reason := sprintf("[%s] High-risk user blocked from network egress in production.", [meta.custom.id])

    decision := {
        "reason": reason,
        "severity": meta.custom.severity,
        "rule_id": meta.custom.id,
    }
}
```

#### 3.4. The Aggregation Layer (Rego)

This centralized package (`cupcake.system.evaluate`) is the entrypoint invoked by the Rust host. It uses OPA's recursive lookup (`..`) to find all Decision Objects generated across the entire policy hierarchy. This is a key component of the Hybrid Model.

```rego
package cupcake.system.evaluate

# METADATA
# scope: package
# entrypoint: true

# The main evaluation rule returns the standardized Decision Set.
evaluate := output if {
    # Recursively find all decisions under cupcake.policies.*
    all_halts := [h | h := data.cupcake.policies..halt[_]]
    all_denials := [d | d := data.cupcake.policies..deny[_]]
    all_blocks := [b | b := data.cupcake.policies..block[_]]
    # ... (other verbs)

    output := {
        "halts": all_halts,
        "denials": all_denials,
        "blocks": all_blocks,
        # ...
    }
}
```

### 4. The Synthesis Layer (Rust Implementation)

The Rust host receives the aggregated Decision Set from WASM. The Synthesis Layer interprets this set and maps it to the specific Claude Code API semantics, ensuring the correct feedback is provided to either Claude or the User.

#### Prioritization Logic

Cupcake enforces a strict hierarchy. If multiple decision types are present, the highest priority wins.

1.  `halt`
2.  `deny` / `block`
3.  `ask`
4.  `allow_override`
5.  `add_context`

#### Semantic Mapping (Rust Pseudocode)

The Rust logic must handle the nuances of the API for each event type.

```rust
fn synthesize_response(event: &ClaudeEvent, decision_set: &DecisionSet) -> JsonResponse {
    // Helper to concatenate all reasons for the winning decision type
    let reasons = aggregate_reasons(&decision_set);

    // Priority 1: Halt (Applies to all events)
    if !decision_set.halts.is_empty() {
        // "continue": false stops everything.
        // "stopReason" is shown ONLY to the user, not Claude.
        return JsonResponse {
            "continue": false,
            "stopReason": format!("Session halted by policy: {}", reasons.halts),
        };
    }

    // Priority 2: Event-Specific Decisions
    match event.hook_event_name {
        "PreToolUse" => {
            if !decision_set.denials.is_empty() {
                // "permissionDecision": "deny" blocks the tool.
                // "permissionDecisionReason" IS shown to Claude for remediation.
                return JsonResponse {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": reasons.denials,
                    }
                };
            }
            if !decision_set.asks.is_empty() {
                // "permissionDecision": "ask" prompts the user.
                // Reason is shown to the user, not Claude.
                 return JsonResponse {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "ask",
                        "permissionDecisionReason": reasons.asks,
                    }
                };
            }
            // ... handle allow_override ...
        },

        "PostToolUse" | "Stop" | "SubagentStop" => {
            if !decision_set.blocks.is_empty() {
                // "decision": "block" prevents stopping or provides feedback post-tool.
                // "reason" IS shown to Claude to guide the next step.
                return JsonResponse {
                    "decision": "block",
                    "reason": reasons.blocks,
                };
            }
        },

        "UserPromptSubmit" => {
             if !decision_set.blocks.is_empty() {
                // "decision": "block" erases the prompt.
                // "reason" is shown to the user, NOT Claude.
                return JsonResponse {
                    "decision": "block",
                    "reason": reasons.blocks,
                };
            }
            // ... handle add_context if not blocked ...
        },
        // ... other events (SessionStart, Notification, etc.) ...
    }

    // Default: Allow if no decisions were triggered
    return JsonResponse { "continue": true };
}
```
